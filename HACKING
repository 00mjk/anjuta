Notes for Developers on contributing to Anjuta
----------------------------------------------

(TO BE EXPANDED OVER TIME - please post submissions to the Anjuta 
Development mailing list or the project maintainer)


Tools
-----

IMPORTANT: please be careful about using Anjuta to develop Anjuta.
Any instabilities in the development version may cause problems.

Anjuta is written using a mixture of C and C++. You will require
the standard GNU toolchain and current stable GNOME libraries to 
build and work with the Anjuta sources.


Submitting patches
------------------

Patches are good, and patches are always welcome! Small, self-contained 
patches are preferred - larger patches which touch on a large number 
of areas of the source tree are more complex to apply and test. 

Patches may be submitted to the project website, to the mailing lists, 
or directly to the project maintainer.

The six-step plan to patching happiness is as follows:

1) All patches should be submitted in *unified* form, i.e. created 
with the command "diff -u" or "cvs diff -u"). 

Make your changes in all files (including the ChangeLog file) and run
"cvs diff -u > patch.diff" in the toplevel anjuta/ directory. This diff
file will contain patches for all of the files together.

Remember to run the cvs diff for the *top* project directory. It will
automatically recurse into the subdirectories and generate the patches.

We ask for patches in this format because:
- more often then not, patches are out of sync with current CVS. This 
can happen because someone is submitting a patch taken against an old 
version of Anjuta, or against anonymous CVS (which is usually out of 
sync for 24 hours). Therefore, the maintainers have to review patches 
manually.
- if a patch file is opened in Anjuta (or editors such as Nedit) in 
"Diff" mode, *unified* formats are more readable and errors and 
mis-syncs are easily detected. Non-unified formats are hard to read.
- unified patches are more intelligent in recognizing changed lines
(because by default there is a 3-line context buffer).

2) Diffs taken against CVS should be preceded by "cvs -z3 up" in 
*all* cases.

3) If anonymous CVS is used, one way of to matching more closely with 
the actual CVS is by running "cvs -z3 up" on all three anonymous CVS 
servers (annocvs1.gnome.org, annocvs2.gnome.org and annocvs3.gnome.org). 
Run the following command in succession for the three servers:

cvs -d:pserver:annocvs[123].gnome.org:/cvs/gnome/anjuta

Details about the anonymous CVS servers can be obtained by issuing the 
command "host annocvs.gnome.org"

4) If the patch is big or is not high priority (i.e. things other than 
stability patches), then either send it to the lead developers directly 
(ccing them together is a nice idea), or post it on the SourceForge page. 
*Never* post big patches to the mailing lists, since they will annoy 
subscribers and are liable to be rejected by the list server. Send
a reference email to the list mentioning that you have sent a patch.

5) *Always* include a ChangeLog entry as part of the diff to ensure that
your entry is also committed directly with your name mentioned.

6) Name the patch with a useful filename. e.g. avoid calling your patch
patch.diff, anjuta.diff or something like that. It is easier to manage
a queue of patches named things like biswa-print-20020605.diff and 
bug-544912.diff as the names are more meaningful. Include the bug number
or your name and the date in the name of the file. Thanks!


General source structure
------------------------

When editing the code, adding new classes or methods, etc. please 
conform with the style already followed in the source files.

If a section of code will require further work, please add helpful
comments of the form /* FIXME: ... */

Conventions:
* _cbs suffix - callbacks
* _gui suffix - UI definitions for windows, dialogs etc.

Key elements:
* src/ - the main Anjuta sources
* scintilla/ - the editor
* widgets/ - additional widgets used
* launcher/ - launcher wrapper used by the debugger
* printing/ - gnome-print support
* tagmanager/ - the tagmanager library
* plugins/ - plugin components (see the sample for more information)


Scintilla
---------

The editing component in Anjuta is Scintilla (www.scintilla.org). 
The Scintilla sources are imported to the scintilla/ directory in the
Anjuta source tree - some reorganisation is required:

Scintilla		Anjuta
---------		------
src/		->	scintilla/
gtk/		->	scintilla/
include/	->	scintilla/include

These are used to compile libscintilla.a, the library which provides
the bulk of Anjuta's editing functions.

The interface into Scintilla is in src/aneditor.cxx. This is based on
SciTE and a lot of care needs to be taken when merging code, since it
combines several different files from the SciTE source tree and is
quite flexible in the ways that they are used. Also, note that lexer
objects from Scintilla must be referenced in src/Makefile.am in order 
to get linked into Anjuta.


Messages and translations
-------------------------

There are a few rules we ask contributors to follow when adding new
message strings and labels to Anjuta.

1. BE CONSISTENT!! 
a) refer to the standard GNOME Word List in the GNOME Style Guide 
(http://developer.gnome.org/documents/style-guide/) when referencing 
different user interface features, and then use the same terminology 
throughout. Try to ensure that your use of words matches the rest of
the code.
b) make sure that mixed case is only used where it makes sense to do so.

Example: "Unable to Start Plug in Module %s".
This message is not ideal since the standard terminology is "plugin" (so 
please do not use "Plug in", "plug-in", etc.). Also, in this case there 
is no reason for the words "start" and "module" to start with an uppercase 
letter.

There are a few standard terms we use - in particular:
- plugin
- Project (always with an uppercase P)

2. Do not use contractions (don't, can't, etc.). These can make a message 
difficult to translate.

3. Do not use colloquial expressions. They may seem cool or amusing, but 
actually they can be hard to translate into all languages. Also, although as 
developers it is OK to have fun, messages with certain language in them can be 
intimidating for new or inexperienced users, and are not very professional.

Example: "You FOOL! I can not attach to myself." 
This message was originally used in the debugger code, and was removed some 
time ago. It is quite fun, but a new user might be put off. 

4. Do not use the first person "I" for referring to Anjuta in messages 
(again, the previous message is an example of this). This is bad practice in 
technical writing. If you need to refer to Anjuta itself, please use the word
"Anjuta"! :-)


Documentation
-------------

The documentation is stored in the manuals/ directory, and consists 
of a set of SGML sources conforming to the GNOME Documentation Project's
Style Guide. Please ensure that all additions also follow these guidelines.

Screenshots used in the manual are processed using The Gimp. Single dialogs
and menus are converted to RGB and the Script-Fu Drop Shadow effect applied 
(with the default settings). All documentation images are in PNG format.

Translations of application messages are stored in the standard po/ 
directory structure at the top level of the source tree.



Graphics
--------

PNG format is preferred for application graphics.

The image filenames are mapped in the file src/pixmaps.h, with helper functions
for manipulating them in src/resources.c. Please use this method for including
graphics and do not use the filenames directly.



ARCHITECTURE:
-------------

FIXME.

1) Event Driven:
----------------

When Anjuta was first designed, the primary goal was to enable the use of 
external unix commnads in a more productive and intutive way. Therefore,
anjuta follows non-blocking input/output operations aggresively. This means
that anjuta UI will not freeze while it performs a lengthy task. All such
jobs are event-driven (I am not refering to the gtk-events here) and works
on asynchronous basis. The example jobs are compilation, debugging, file search,
class updates etc. While aynchronous event-driven implementation is more
complex than it's synchronous counter part, it gives a smooth and non-frustrative
operation. :-)

1a) Executing external commands in non-blocking mode:
-----------------------------------------------------

launcher (launcher.[c,h]) is the class responsible for executing external commands in
non-blocking mode. launcher_execute takes 4 arguments, first is the command
to be executed, second is the stdout callback, stderr callback and the child
terminated callback. They are called when there is chars available in the
stdout and stderr and when the child terminates respectively.

/* Start a job. */
/* command_str is the command to be executed */
/* stdout_func is the callback to be called when chars are received in STDOUT from the process */
/* stderr_func is the callback to be called when chars are received in STDERR from the process */
/* commnad_terminated is the callback to be called when the job is completed or terminated */
gboolean launcher_execute(gchar* command_str,
                               void (*stdout_func)(gchar*),
                               void (*stderr_func)(gchar*),
                               void (*command_terminated)(gint status, time_t time));

The three callbacks stated above should be of the following prototype:

/* The function names are arbitary */
void stdout_func (gchar * chars);
void stderr_func (gchar * chars);
void command_terminated (int return_status, time_t total_time);

Refer to the file launcher.h for further information.

Remember to use this launcher instead of gtk/glib non-blocking IO interface.

1b) Process synchronization:
----------------------------

The rest of the processes, which are quick (less that 1/10 sec) in execution
or whose IO interfaces are not necessary, can safely be forked just like a
normal fork. For shorter execution wait() system call would suffice it's
synchronization when the process ends, but for longer jobs, asynchronous
notification is suggested.

For asynchronos notification of child termination, a few additional steps
are needed to be done just after the fork() call. Register the child pid
with the call to anjuta_register_child(). It takes two arguments, first the
child pid and second, the callback to be called when the process with that
pid terminates. The call to the callback is shipped with the child exit status.

/* Registers the child for asynchronous notification */
void anjuta_register_child_process (pid_t pid,
			       void (*callback) (int status, gpointer user_data),
			       gpointer user_data);

/* Unregisters the child. No notification will be emited thereafter. */
void anjuta_unregister_child_process (pid_t pid);

The callback should be of the following prototype:

/* function name choosen arbitarily */
void child_terminated_callback (int status, gpointer user_data);

For further information, refer to the file anjuta.c.

WARNING: Do not hook up the signal SIGCHLD, for the similar purpose. Just use
the above method to perform the same thing. SIGCHLD is used by Anjuta 
internally to manage the children.

2) How to add new menu items in the Main Menu:
----------------------------------------------
FIXME.

2a) How to add new menu items in the Edit->Insert menu:
-------------------------------------------------------
There are 6 files which need to be updated.

* main_menubar_def.h - update insert_submenu_uiinfo (and others 
e.g. inserttext1_submenu_uiinfo) to add the item, help text and name of the 
callback function.
* main_menubar.h - update struct _EditSubMenu with the name of the menu widget
* main_menubar.c - update the array of items referenced around mb->edit.insert_*
* mainmenu_callbacks.h, mainmenu_callbacks.c - declare the name of the new callback 
function in the header file, and add the new function itself based on the
existing on_insert_*() functions
* controls.c - update the list of gtk_widget_set_sensitive calls with a new entry for 
the menu widget em->insert_* (as specified in main_menubar.h)


3) How to add new toolbar items in the Toolbars:
------------------------------------------------
FIXME.


4) Dialogs and Windows:
-----------------------
When adding new dialogs or windows, please ensure...
- the WMCLASS attribute is set to a unique value
- a default button is defined


5) Property/Config management:
------------------------------
Anjuta does not use gconf (at least, not now), and instead has its own config 
manager/properties manager. The source for this is in src/properties.cxx.
There are some advantages in using this over gconf, including the ability to
do variable substitution. Anjuta needs these advantages to operate properly.
Even though gconf have additional advantages, we are not really concerned about
them right now. In future, things may change, though.

FIXME.

When Anjuta was started, there were not many application support libraries.
To cope up with the requirements, anjuta had to implement the supports within
itself. And it is still going.

6) Global shortcut keys:
------------------------

The following callback (located in anjuta.c) :

gint
on_anjuta_window_key_press_event (GtkWidget   *widget,
				  GdkEventKey *event,
				  gpointer     user_data)

is called when some key is pressed in the whole environnement, because the
event is triggered off by the main GtkWindow. It has been created for navigating
between the different buffers (Ctrl-[Shift]-Tab).

It's aim is to implement global shortcut keys. For now on, it only works in the main window.

Note : It's possible to install such an handler in the other windows if it's
really needed, so the new callback can propagate the event to app (the GnomeApp)
and we'll have a central place for those shortcuts.

6a) How to add a global shortcut:
---------------------------------

It's pretty self-explainatory, but here's the "howto" :

Just before the callback, you have some GDK modifiers "shortcuts", just because
it's a pain to write this each time, and the mxy make you see in an instant
which modifiers are used (Shift or Control) :

enum {
	m__ = 0,
	mS_ = GDK_SHIFT_MASK,
	m_C = GDK_CONTROL_MASK,
	mSC = GDK_SHIFT_MASK | GDK_SHIFT_MASK
};

These are to ease filling the structure (1) : 

You add an id for your shortcut in the enum : 

enum {
	ID_NEXTBUFFER = 0,
	ID_PREVBUFFER = 1
	...
};

Then, you add a line with the modifiers used, the GDK corresponding key, and the
shortcut id.

(1):

static ShortcutMapping global_keymap[] = {
	{ m_C, GDK_Tab,		 ID_NEXTBUFFER },
	{ mSC, GDK_ISO_Left_Tab, ID_PREVBUFFER },
	...
	{ 0,   0		 0 }
};

Finally, you add a case in the callback's switch :

gint
on_anjuta_window_key_press_event (GtkWidget   *widget,
	...

	switch (global_keymap[i].id) {
	case ID_xxx:
		<statements>

		break;
	}
	default:
		return FALSE;
	}

	...
	

7) How to add a new project type:
---------------------------------

It is currently a bit difficult - the code is spread around and not
very consistent. 

Things to do as a start:

- in project_type.c and add an array for your project type (this 
is well-commented). Add it to the load_project_type function.

- in project_dbase.h: Add your project type to the enum PROJECT_TYPE_*

- in wizard_gui.c: create_project_type_selection_page():
Add an icon to the list for the project type and define it in pixmaps.h
(If you are a bad artist, it might be good to ask for help with this on 
the mailing list)

- appwiz_page1.c: Add your type in on_wizard_app_icon_select()

So that was the easy part ;-)

Now search for every occurence of PROJECT_TYPE_* and project_type_* in 
the codebase, and decide if you have anything to add (there are about 
10 places where it occurs).

Good luck!

8) How to correctly credit people:
----------------------------------

New contributors must always be credited. There are three files which 
must be updated:

	* THANKS
	* widgets/e-shell-about-box.c
	* manuals/anjuta-manual/C/authors.sgml

You should also ensure that you submit headed ChangeLog entries with a 
name and e-mail address when you submit a patch.
