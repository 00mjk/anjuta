# Anjuta internal configuration file

#----------------- WARNING ------------------------------------#
# Any modification in this file without knowing proper internal
# working of Anjuta may lead to instabilites.
#----------------- WARNING ------------------------------------#

# Anjuta uses this file for internal operations,
# therefore this file should never be modified.
# Only Anjuta developers will be tampering with this file. 

# Any modification if needed should be approved by the Anjuta
# developers, so that the source code is also changed (if needed)
# and the changes incorporated in the next release of Anjuta.

##################################################
# Filters to be used in file open/close/save etc #
##################################################
filter.cpp=C/C++ (.c;.cc;.cpp;.cxx;.cs;.h;.hh;.hxx;.hpp;.dlg;.rc;.rc2;.mak)|\
*.c;*.cc;*.cpp;*.cxx;*.cs;*.h;*.hh;*.hxx;*.hpp;*.dlg;*.rc;*.rc2;*.mak;makefile|

############################################
# File patterns defined for all file types #
############################################
file.patterns.c=*.c
file.patterns.cpp=*.cpp;*.cxx;*.cc
file.patterns.header=*.h;*.hh;*.hpp;*.hxx

####################################################
# Lexer to be used for corresponding file patterns #
####################################################
lexer.$(file.patterns.c)=cpp
lexer.$(file.patterns.cpp)=cpp
lexer.$(file.patterns.header)=cpp

################################################
# File type corresponding to the file patterns #
################################################
filetype.$(file.patterns.c)=c
filetype.$(file.patterns.cpp)=cpp
filetype.$(file.patterns.header)=header

##################
# Keywords for C #
##################
keywordclass.c=asm auto bool break case char const continue \
do double else enum explicit export extern float for \
goto if inline int long \
register return short signed sizeof static struct switch \
default typedef typename union unsigned \
void volatile wchar_t while TRUE FALSE NULL

keywords.$(file.patterns.c)=$(keywordclass.c)

####################
# Keywords for C++ #
####################
keywordclass.cpp=\
catch class const_cast dynamic_cast delete false friend mutable namespace new \
operator private protected public this throw true virtual using typeid \
template reinterpret_cast static_cast

keywords.$(file.patterns.cpp)=$(keywordclass.cpp) $(keywordclass.c)
keywords.$(file.patterns.header)=$(keywordclass.cpp) $(keywordclass.c)

#######################################
# Characters definition for C and C++ #
#######################################
word.chars.cxx=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.cpp)=$(word.chars.cxx)
word.characters.$(file.patterns.c)=$(word.chars.cxx)
word.characters.$(file.patterns.header)=$(word.chars.cxx)

#####################################################################
# Keywords after which auto indention will take place for C and C++ #
#####################################################################
statement.indent.$(file.patterns.cpp)=5 case catch class default do else for if \
private protected public struct try union while switch

statement.indent.$(file.patterns.header)=5 case catch class default do else for if \
private protected public struct try union while switch

statement.indent.$(file.patterns.c)=5 case do else for if struct union while switch

#############################################
# End of statements character for C and C++ #
#############################################
statement.end.$(file.patterns.cpp)=10 ;
statement.end.$(file.patterns.c)=10 ;
statement.end.$(file.patterns.header)=10 ;

#####################################
# Statements lookback for C and C++ #
#####################################
statement.lookback.$(file.patterns.cpp)=20
statement.lookback.$(file.patterns.c)=20
statement.lookback.$(file.patterns.header)=20

#########################################
# Start and end of blocks for C and C++ #
#########################################
block.start.$(file.patterns.cpp)=10 {
block.end.$(file.patterns.cpp)=10 }
block.start.$(file.patterns.c)=10 {
block.end.$(file.patterns.c)=10 }
block.start.$(file.patterns.header)=10 {
block.end.$(file.patterns.header)=10 }

##############################################
# Other properties for C and C++ #
##############################################
styling.within.preprocessor=1

file.has.folds.$(file.patterns.cpp)=1
file.has.tags.$(file.patterns.cpp)=1
file.can.autoformat.$(file.patterns.cpp)=1
file.is.source.$(file.patterns.cpp)=1

file.has.folds.$(file.patterns.c)=1
file.has.tags.$(file.patterns.c)=1
file.can.autoformat.$(file.patterns.c)=1
file.is.source.$(file.patterns.c)=1

file.has.folds.$(file.patterns.header)=1
file.has.tags.$(file.patterns.header)=1
file.can.autoformat.$(file.patterns.header)=1
file.is.source.$(file.patterns.header)=1

apiclass.gnome=$(anjuta.data.directory)/linux-gnome-c.api
api.$(file.patterns.header)=$(apiclass.gnome)
api.$(file.patterns.c)=$(apiclass.gnome)
api.$(file.patterns.cpp)=$(apiclass.gnome)

##############################
# C and C++ style definition #
##############################

# Whitespaces
style.cpp.0=$(style.default.whitespace)
# Comment
style.cpp.1=$(style.default.comment)
# Line Comment
style.cpp.2=$(style.default.comment)
# Doc comment
style.cpp.3=$(style.default.comment)
# Number
style.cpp.4=$(style.default.number)
# Keyword
style.cpp.5=$(style.default.keyword)
# Keyword 2
style.cpp.16=$(style.default.localkeyword)
# Keyword 3
style.cpp.19=$(style.default.syskeyword)
# Double quoted string
style.cpp.6=$(style.default.doublequote)
# Single quoted string
style.cpp.7=$(style.default.singlequote)
# UUIDs (only in IDL)
style.cpp.8=fore:#804080
# Preprocessor
style.cpp.9=$(style.default.preprocessor)
# Operators
style.cpp.10=$(style.default.operator)
# Identifiers
style.cpp.11=$(style.default.identifier)
# End of line where string is not closed
style.cpp.12=$(style.default.unclosedstring)
# Verbatim strings for C#
style.cpp.13=fore:#007F00,back:#E0FFE0,eolfilled
# Braces are only matched in operator style
braces.cpp.style=10

######################################################
# Default Commands for handling different file types #
######################################################

command.compile.file.$(file.patterns.c)=gcc $(anjuta.compiler.flags) -c "$(current.file.name.ext)" -o "$(current.file.name).o"
command.build.file.$(file.patterns.c)=gcc $(anjuta.compiler.flags) $(anjuta.linker.flags) "$(current.file.name.ext)" -o "$(current.file.name)"
command.execute.file.$(file.patterns.c)="$(current.full.filename)" $(anjuta.program.arguments)

command.compile.file.$(file.patterns.cpp)=g++ $(anjuta.compiler.flags) -c "$(current.file.name.ext)" -o "$(current.file.name).o"
command.build.file.$(file.patterns.cpp)=g++ $(anjuta.compiler.flags) $(anjuta.linker.flags) "$(current.file.name.ext)" -o "$(current.file.name)"
command.execute.file.$(file.patterns.cpp)="$(current.full.filename)" $(anjuta.program.arguments)
