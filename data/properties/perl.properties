# Anjuta internal configuration file

#----------------- WARNING ------------------------------------#
# Any modification in this file without knowing proper internal
# working of Anjuta may lead to instabilites.
#----------------- WARNING ------------------------------------#

# Anjuta uses this file for internal operations,
# therefore this file should never be modified.
# Only Anjuta developers will be tampering with this file. 

# Any modification if needed should be approved by the Anjuta
# developers, so that the source code is also changed (if needed)
# and the changes incorporated in the next release of Anjuta.

##################################################
# Filters to be used in file open/close/save etc #
##################################################
filter.perl=Perl (.pl;.pm)|*.pl;*.pm|

############################################
# File patterns defined for all file types #
############################################
file.patterns.perl=*.pl;*.pm;*.cgi;*.pod

####################################################
# Lexer to be used for corresponding file patterns #
####################################################
lexer.$(file.patterns.perl)=perl

icon.$(file.patterns.perl)=file_exec.png

################################################
# File type corresponding to the file patterns #
################################################
filetype.$(file.patterns.perl)=perl

#####################
# Keywords for perl #
#####################
keywords.$(file.patterns.perl)=\
NULL __FILE__ __LINE__ __PACKAGE__ __DATA__ __END__ AUTOLOAD \
BEGIN CORE DESTROY END EQ GE GT INIT LE LT NE CHECK abs accept \
alarm and atan2 bind binmode bless caller chdir chmod chomp chop \
chown chr chroot close closedir cmp connect continue cos crypt \
dbmclose dbmopen defined delete die do dump each else elsif endgrent \
endhostent endnetent endprotoent endpwent endservent eof eq eval \
exec exists exit exp fcntl fileno flock for foreach fork format \
formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname \
gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername \
getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent \
getpwent getpwnam getpwuid getservbyname getservbyport getservent \
getsockname getsockopt glob gmtime goto grep gt hex if index \
int ioctl join keys kill last lc lcfirst le length link listen \
local localtime lock log lstat lt m map mkdir msgctl msgget msgrcv \
msgsnd my ne next no not oct open opendir or ord our pack package \
pipe pop pos print printf prototype push q qq qr quotemeta qu \
qw qx rand read readdir readline readlink readpipe recv redo \
ref rename require reset return reverse rewinddir rindex rmdir \
s scalar seek seekdir select semctl semget semop send setgrent \
sethostent setnetent setpgrp setpriority setprotoent setpwent \
setservent setsockopt shift shmctl shmget shmread shmwrite shutdown \
sin sleep socket socketpair sort splice split sprintf sqrt srand \
stat study sub substr symlink syscall sysopen sysread sysseek \
system syswrite tell telldir tie tied time times tr truncate \
uc ucfirst umask undef unless unlink unpack unshift untie until \
use utime values vec wait waitpid wantarray warn while write \
x xor y

word.characters.$(file.patterns.perl)=$(chars.alpha)$(chars.numeric)_

file.interpreted.$(file.patterns.perl)=1
file.is.source.$(file.patterns.perl)=1
file.has.folds.$(file.patterns.perl)=1

statement.indent.$(file.patterns.perl)=5 sub case do else elsif for \
foreach if unless until while

statement.end.$(file.patterns.perl)=10 ;

statement.lookback.$(file.patterns.perl)=20

block.start.$(file.patterns.perl)=10 {
block.end.$(file.patterns.perl)=10 }

comment.block.perl=#~

colour.perl.heredoc=$(colour.embedded.comment)

###############
# Perl styles #
###############

# White space
style.perl.0=$(style.default.whitespace)
# Here document
style.perl.1=fore:#000040,back:#F0F0FF,eolfilled
# Comment
style.perl.2=$(style.default.comment)
# POD
style.perl.3=fore:#004000,back:#E0FFE0,eolfilled
# Number
style.perl.4=$(style.default.number)
# Keyword
style.perl.5=$(style.default.keyword)
# Double quoted string
style.perl.6=$(style.default.doublequote)
# Single quoted string
style.perl.7=$(style.default.singlequote)
# Symbols 
style.perl.8=fore:#007F7F
# Preprocessor
style.perl.9=$(style.default.preprocessor)
# Operators
style.perl.10=$(style.default.operator)
# Identifiers
style.perl.11=$(style.default.identifier)
# Scalars
style.perl.12=fore:#000000,back:#FFE0E0
# Array: @var
style.perl.13=fore:#000000,back:#FFFFE0
# Hash: %var
style.perl.14=fore:#000000,back:#FFE0FF
# Symbol table: *var
style.perl.15=fore:#000000,back:#E0E0E0
# Regex: /re/ or m{re}
style.perl.17=fore:#000000,back:#A0FFA0
# Substitution: s/re/ore/
style.perl.18=fore:#000000,back:#F0E080
# Long Quote (qq, qr, qw, qx) -- obsolete: replaced by qq, qx, qr, qw
style.perl.19=fore:#FFFF00,back:#8080A0
# Back Ticks
style.perl.20=fore:#FFFF00,back:#A08080
# Data Section
style.perl.21=fore:#600000,back:#FFF0D8,eolfilled
# Here-doc (delimiter)
style.perl.22=fore:#000000,back:#DDD0DD
# Here-doc (single quoted, q)
style.perl.23=fore:#7F007F,back:#DDD0DD,eolfilled,notbold
# Here-doc (double quoted, qq)
style.perl.24=fore:#7F007F,back:#DDD0DD,eolfilled,bold
# Here-doc (back ticks, qx)
style.perl.25=fore:#7F007F,back:#DDD0DD,eolfilled,italics
# Single quoted string, generic
style.perl.26=fore:#7F007F,$(font.monospace),notbold
# qq = Double quoted string
style.perl.27=$(style.perl.6)
# qx = Back ticks
style.perl.28=$(style.perl.20)
# qr = Regex
style.perl.29=$(style.perl.17)
# qw = Array
style.perl.30=$(style.perl.13)
# Braces are only matched in operator style
braces.perl.style=10

######################################################
# Default Commands for handling different file types #
######################################################

command.compile.file.$(file.patterns.perl)=perl -c "$(current.file.name.ext)"
command.build.file.$(file.patterns.perl)=
command.execute.file.$(file.patterns.perl)=perl "$(current.full.filename.ext)"

