// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

// Implemented by all plugins that can open files
interface IAnjutaFile
{
	void open (const gchar *filename);
	gchar* get_filename ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		void ::save_point (gboolean entered);
		
		void save ();
		void save_as (const gchar *filename);
		
		void set_dirty (gboolean dirty);
		gboolean is_dirty ();
	}
}

// Stream interface
interface IAnjutaStream
{
	#include <stdio.h>
	
	void open (FILE *stream);
	
	interface IAnjutaStreamSavable
	{
		void save (FILE *stream);
	}
}

interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}
	
	enum Marker
	{
		NONE,
		LIGHT,
		ATTENTIVE,
		INTENSE
	}
	
	void mark (gint location, Marker marker);
	void unmark (gint location);
	Marker get_mark (gint location);
	GList* get_all_marks ();
}

// Sandbox gives restricted and localized access to the implementation
interface IAnjutaSandBox
{
	enum Error
	{
		ACCESS_VIOLATION
	}
	
	// Invokers wishing to pass the box down to others, should lock
	// their current box. lock_signature is just a unique key to
	// protect invoker's box and only a matching lock_signature with the last
	// push lock can pop open a lock, otherwise ACCESS_VIOLATION error will
	// be thrown.
	void push_lock (gpointer lock_signature);
	void pop_lock (gpointer lock_signature);
	
	// Contexts are, well, contexts. Interesting things happen in contexts.
	interface IAnjutaContext
	{
		// Contexts can only be begun or ended while the lock stack is
		// empty. It basically means only the owner of this context can call
		// these, presumably to initialize or finalize the context. Any other
		// invoker trying to call them (that is, lock stack is not empty),
		// will result in ACCESS_VIOLATION error.
		void begin();
		void end();
		
		// Clears current level. That is, anything done since last push_lock
		// is cleared and context state restored to just after the push.
		void clear();
		
		// Text context represents a hierarchially indented
		// text. Each call to push_lock starts a level and automatically
		// indents subsequent render texts to that level.
		interface IAnjutaContextText
		{
			// Sets indentation level. Indentations should be stacked for
			// each level, because they might have different indentation sizes.
			void set_indentation (gint spaces);
			
			// Returns current level's indentation in space. Presumably to 
			// do some calculations before rendering a text.
			gint get_indentation ();
			
			// renders the text.
			void render (const gchar *text);
		}

		// Tree context represents a hierarchial tree. Each render() renders
		// a tree node. down() takes it down one level and up() takes it to the
		// parent node. Note that tree depths are not equivalent to context
		// levels. A context level might consist of many tree depths.
		interface IAnjutaContextList
		{
			#include <gdk/gdkpixbuf.h>
			
			enum Size
			{
				MINI,
				SMALL,
				LARGE
			}
			
			// Sets the size of the context.
			void set_size (Size size);
			
			// Gets the size of the context.
			Size get_size ();
			
			// Renders a mini view.
			void render (GdkPixbuf *image, const gchar *text, GValue* data);
			
			// Tree context represents a hierarchial tree. Each render() renders
			// a tree node. down() takes it down one level and up() takes it to the
			// parent node. Note that tree depths are not equivalent to context
			// levels. A context level might consist of many tree depths.
			interface IAnjutaContextTree
			{
				void down ();
				void up ();
			}
		}
	}
}

// Implemented by plugins which can render itself
interface IAnjutaRenderable
{
	#include "ianjuta-context.h"
	
	enum Error
	{
		NOT_SUPPORTED
	}
	// Render itself in the given context. Note that the renderable should
	// automatically determine the type of context and render accordingly.
	// It also means the context implementor should really not implement
	// more than one context type, avoiding ambiguity in renderable.
	void render (IAnjutaContext *context);
}

interface IAnjutaIterable
{
	enum Error
	{
		INVALID_ITER,
		UNSETTABLE,
	}
	
	// Implementation dependent data to store iter info. Should
	// not be used by the invoker.
	struct Iter
	{
		gpointer a;
		gpointer b;
		gpointer c;
		gpointer d;
		gpointer e;
	}
	
	// Iter at begining
	Iter* begin ();
	
	// iter at end
	Iter* end ();
	
	// Copy iter
	Iter* copy (Iter *iter);
	
	// iters returned by begin(), end() and copy must be freeed with this
	void free_iter (Iter *iter);
	
	// Resets the iter to the begining
	void reset (Iter *iter);
	
	// If the iter value is settable
	gboolean get_settable ();
	
	// Forwards the iter. In recursable, it will desent into first node
	// if current iter has children.
	void next (Iter* iter);
	
	// Reverse the iter. In recursable, it will come up the parent node
	// if current iter is first child.
	void previous (Iter* iter);
	
	// Call callback for each iter starting from given iter.
	// Give NULL iter to call for all nodes
	void foreach (Iter* start_iter, GCallback *callback, gpointer user_dat);
	
	// Interpretation of 'data' really depends on implementation
	gpointer get (Iter *iter);
	void set (Iter *iter, gpointer data);
	
	// Checks if the iter is valid
	gboolean valid (Iter* iter);
	
	interface IAnjutaIterableTree
	{
		// Set iter to parent
		void parent (Iter *iter);
		
		// Get first child
		Iter* get_children (Iter *ter);
		
		gboolean has_children (Iter *iter);
	}
}

// Implemented by plugins which can transform it's data into some output.
interface IAnjutaTransformable
{
	void transform();
}

// Implemented by plugins which can build (e.g module manager plugins).
interface IAnjutaBuildable
{
	void compile (const gchar* filename);
	void build ();
	void clean ();
}

// Studio profile. Like c++ profile, java profiler etc.
interface IAnjutaProfile
{
	#include <libanjuta/e-splash.h>
	
	void load(ESplash *splash);
}

interface IAnjutaHelp
{
	void search (const gchar *query);
}

// Loaders can deterime correct plugin to open a file or stream.  They
// themselves can not load it, but will correctly redirect the request to
// an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
// IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
// requirements.
interface IAnjutaLoader
{
	// Loaders can deterime correct plugin to open a file
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @filename: File to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (gchar *filename, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @filename: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (gchar *filename);
	}
	
	// StreamLoaders can deterime correct plugin to open a stream.
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	enum Error
	{
		DOESNT_EXIST
	}
	
	void   goto_line (gint lineno);
	gchar* get_selection ();
	gchar* get_text (gint start, gint end);
	gchar* get_attributes (gint start, gint end);
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	
	void goto_file_line (const gchar *file, gint lineno);
	IAnjutaEditor* get_current_editor ();
	void set_current_editor (IAnjutaEditor *editor);
	GList* get_editors ();
}

interface IAnjutaMessageView
{
	// Signals
	void ::message_clicked (const gchar *message);

	void append (const gchar *message);
	void clear ();
	void select_next ();
	void select_previous ();
	gint get_line ();
	gchar* get_message ();
	GList* get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	void add_view (const gchar *name, const gchar *icon);
	void remove_view (IAnjutaMessageView *view);
	IAnjutaMessageView* get_current_view ();
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	GList* get_all_views ();
	void set_current_view (IAnjutaMessageView *view);
}

interface IAnjutaFileManager
{
	void ::section_changed (const gchar *filename);
	
	void set_root (const gchar *root_directory);
	gchar* get_selected ();
	void set_selected (const gchar *filename);
}

/* interface IAnjutaModule
 * {
 * }
 * 
 * // Implemented by plugins which can manage something
 * interface IAnjutaManager
 * {
 * 	GValue* get (const gchar *key);
 * 	void set (const gchar *key, GValue *value);
 * 	
 * 	// Implemented by plugins which can manage metafiles
 * 	interface IAnjutaMataManager
 * 	{
 * 		gchar* get_name ();
 * 	
 * 		interface IAnjutaProjectManager
 * 		{
 * 			void configure();
 * 		}
 * 		
 * 		interface IAnjutaModuleManager
 * 		{
 * 			void ::file_added (const gchar *filename);
 * 			void ::module_added (const gchar *module_name);
 * 			
 * 			void add_file (const gchar *filename);
 * 			void remove_file (const gchar *filename);
 * 			
 * 			gchar* get_path (const gchar *filename);
 * 			
 * 			interface IAnjutaModuleSource
 * 			{
 * 				void ::target_added (const gchar *target);
 * 				
 * 				enum TargetType
 * 				{
 * 					SLIB,
 * 					DLIB,
 * 					BIN,
 * 					EXTRA
 * 				}
 * 				void add_target (const gchar *target_name);
 * 				void remove_target (const gchar *target_name);
 * 			}
 * 		}
 * 	}
 * }
 */
