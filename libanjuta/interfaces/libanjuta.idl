// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

// Implemented by all plugins that can open files
interface IAnjutaFile
{
	/**
	 * ianjuta_file_open:
	 * @obj: Self
	 * @uri: URI to open.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given URI.
	 */
	void open (const gchar *uri);
	
	/**
	 * ianjuta_file_get_uri:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the URI that was opened with ianjuta_file_open().
	 *
	 * Return value: The last URI opened.
	 */
	gchar* get_uri ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		/**
		 * IAnjutaFileSavable::save_point:
		 * @obj: Self
		 * @entered: TRUE if save point is entered, FALSE otherwise.
		 * 
		 * This signal is emitted when the editor enters or leave the save
		 * point. Save point is the point where the contents were saved to
		 * non-volatile memory (e.g. disk). For example, performing undo/redo
		 * will enter or leave the save point in an editor.
		 */
		void ::save_point (gboolean entered);
		
		/**
		 * IAnjutaFileSavable::saved:
		 * @obj: Self
		 * @uri: URI where the content is saved.
		 * 
		 * This signal is emitted when the content is saved.
		 */
		void ::saved (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_save:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to the original URI from which it was loaded.
		 */
		void save ();
		
		/**
		 * ianjuta_file_savable_save_as:
		 * @obj: Self
		 * @uri: URI to save the content.
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to a different URI.
		 */
		void save_as (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_set_dirty:
		 * @obj: Self
		 * @dirty: 
		 * @err: Error propagation and reporting
		 * 
		 * if @dirty is TRUE, sets dirty for the content. Save point will be
		 * left and the content will be considered not saved. Otherwise,
		 * content will considered saved and save-point will be entered.
		 */
		void set_dirty (gboolean dirty);
		
		/**
		 * ianjuta_file_savable_is_dirty:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Returns the dirty status of the content.
		 *
		 * Return value: TRUE if dirty, FALSE otherwise.
		 */
		gboolean is_dirty ();
	}
}

// Stream interface
interface IAnjutaStream
{
	#include <stdio.h>
	
	/**
	 * ianjuta_stream_open:
	 * @obj: Self
	 * @stream: Stream to open from.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given stream.
	 */
	void open (FILE* stream);
	
	interface IAnjutaStreamSavable
	{
		/**
		 * ianjuta_stream_save:
		 * @obj: Self
		 * @stream: Stream to save to.
		 * @err: Error propagation and reporting
		 *
		 * The implementor saves the content to the given stream.
		 */
		void save (FILE* stream);
	}
}

// Markables.
// For example, IAnjutaEditor extension - editor capable of marking lines
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

	enum Marker
	{
		NONE,
		BASIC,
		LIGHT,
		ATTENTIVE,
		INTENSE
	}

	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	void unmark (gint location, Marker marker);
	gboolean is_marker_set (gint location, Marker marker);
	void delete_all_markers (Marker marker);
}

interface IAnjutaIterable
{
	// Set iter to first element position. Returns FALSE if
	// there is no element in the iterable (hence does not have last).
	gboolean first ();
	
	// Set the iter position to next element position. Returns FALSE if there
	// is no next element.
	gboolean next ();
	
	// Set the iter position to previous element position. Returns FALSE if
	// there is no previous element.
	gboolean previous ();
	
	// Set iter position to last element position. Returns FALSE if
	// there is no element in the iterable (hence does not have last).
	gboolean last ();
	
	// Call callback for each element.
	void foreach (GFunc callback, gpointer user_data);
	
	// Gets the value at current iter position.
	// Interpretation of 'data' really depends on implementation and is of
	// type 'data_type'. get_nth() gets the element at given position without
	// altering the position of current iter.
	gpointer get (GType data_type);
	gpointer get_nth (GType data_type, gint position);
	
	// Index of the current iter in the iterable
	gint get_position ();
	
	// Length of the iterable
	gint get_length ();
	
	// If the iterable is settable
	gboolean get_settable ();
	
	// Sets the value at current iter position. The iterable be be settable.
	// Interpretation of 'data' really depends on implementation. The data
	// must be of type 'data_type'.
	void set (GType data_type, gpointer data);
	void set_nth (GType data_type, gpointer data, gint position);
	
	interface IAnjutaIterableTree
	{
		// Set iter position to parent of curernt iter. If there is no parent,
		// returns FALSE (current iter position is not changed)
		gboolean parent ();
		
		// Iter position set to first child of current iter. If there is no
		// children, return NULL (iter position is not changed).
		gboolean children ();
		
		// Returns true if current iter has children
		gboolean has_children ();
		
		// Call callback for each element in post order.
		void foreach_post (GFunc callback, gpointer user_data);
		
		// Call callback for each element in pre order.
		void foreach_pre (GFunc callback, gpointer user_data);
	}
}

// Implemented by plugins which can build (e.g module manager plugins).
interface IAnjutaBuildable
{
	void build (const gchar *uri);
	void clean (const gchar *uri);
	void install (const gchar *uri);
	void configure (const gchar *uri);
	void generate (const gchar *uri);
	void execute (const gchar *uri);
}

// Studio profile. Like c++ profile, java profile etc.
interface IAnjutaProfile
{
	#include <libanjuta/e-splash.h>
	
	void load ();
}

interface IAnjutaHelp
{
	void search (const gchar *query);
}

// Loaders can deterime correct plugin to open a file or stream.  They
// themselves can not load it, but will correctly redirect the request to
// an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
// IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
// requirements.
interface IAnjutaLoader
{
	// Returns all plugins supporting loader interface.
	GSList * find_plugins ();
	
	// Loaders can deterime correct plugin to open a file
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @uri: URI to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (const gchar *uri, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @uri: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (const gchar *uri);
	}
	
	// StreamLoaders can deterime correct plugin to open a stream.
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	enum Error
	{
		DOESNT_EXIST
	}
	
	// Signals.
	void   ::char_added (gint position, gchar ch);
	void   ::update_ui ();

	void   erase_all ();	
	void   insert (int position, const gchar *text, gint length);
	void   append (const gchar *text, gint length);
	void   goto_line (gint lineno);
	void   goto_position (gint position);
	gchar* get_selection ();
	void   replace_selection (const gchar *text, gint length);
	gchar* get_text (gint start, gint end);
	gchar* get_attributes (gint start, gint end);
	gint   get_position ();

	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current line in the editor.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();

	gint   get_length ();
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	const gchar * get_full_filename (const gchar *file);
	IAnjutaEditor* find_editor_with_path (const gchar *file_path);
	void goto_file_line (const gchar *file, gint lineno);
	void goto_file_line_mark (const gchar *file, gint lineno, gboolean mark);
	IAnjutaEditor* get_current_editor ();
	void set_current_editor (IAnjutaEditor *editor);
	GList* get_editors ();

	// New editor buffer
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);
}

interface IAnjutaMessageView
{
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}
	
	// Signals
	void ::message_clicked (const gchar *message);
	void ::buffer_flushed (const gchar *line);
	
	/* Buffer methods */
	void buffer_append (const gchar *text);
	void append (Type type, const gchar *summary, const gchar *details);
	void clear ();
	void select_next ();
	void select_previous ();
	const gchar* get_current_message ();
	GList* get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);
	
	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 *
	 * Return value: The new message-view
	 */
	void remove_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of 
	 * the notebook or NULL if the message-manager is empty.
	 *
	 * Return value: Current view; #IAnjutaMessageView object.
	 * NULL, if there is no views.
	 */
	IAnjutaMessageView* get_current_view ();
	
	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	
	/**
	 * ianjuta_message_manager_get_all_views:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: A GList* of all views. You must not
	 * manipulate the list.
	 */
	GList* get_all_views ();
	
	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	void set_current_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_set_view_title:
	 * @obj: Self
	 * @view: A message view
	 * @title: Sets the title of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the title of view.
	 *
	 */
	void set_view_title (IAnjutaMessageView *view, const gchar *title);
}

interface IAnjutaFileManager
{
	void ::section_changed (const gchar *uri);
	
	void set_root (const gchar *root_uri);
	gchar* get_selected ();
	void set_selected (const gchar *uri);
}

interface IAnjutaTerminal
{
	#include <sys/types.h>
	pid_t execute_command (const gchar* directory, const gchar *command);
}

interface IAnjutaProjectManager
{
	enum ElementType
	{
		UNKNOWN,
		SOURCE,
		TARGET,
		GROUP
	}
	
	enum TargetType
	{
		TARGET_UNKNOWN,
		TARGET_SHAREDLIB,
		TARGET_STATICLIB,
		TARGET_EXECUTABLE
	}
	
	// Signals
	void ::element_added (const gchar *element_uri);
	void ::element_removed (const gchar *element_uri);
	void ::element_selected (const gchar *element_uri);
	
	// Methods
	ElementType get_element_type (const gchar *element_uri);
	GList* get_elements (ElementType element_type);
	
	TargetType get_target_type (const gchar *target_uri);
	GList* get_targets (TargetType target_type);
	
	gchar* get_parent (const gchar *element_uri);
	GList* get_children (const gchar *element_uri);
	gchar* get_selected ();
	
	gboolean add_source (const gchar *source_uri, const gchar *target_uri);
	gboolean add_target (const gchar *target_uri);
	gboolean add_group (const gchar *group_uri);
	gboolean is_open ();
}

interface IAnjutaTodo
{
	void load(gchar *uri);
}

interface IAnjutaWizard
{
	void activate();
}

interface IAnjutaDebuggerManager
{
	gboolean is_active ();
	gboolean is_busy ();
	
	void start (const gchar *prog_uri, const GList *source_search_directories);
	gboolean stop ();
}

interface IAnjutaDebugger
{
	// Sinals
	void ::busy (gboolean busy_state);
	
	gboolean is_busy ();

	void load (const gchar *prog_uri, const GList *source_search_directories);

	void run_continue ();
	void step_in ();
	void step_over ();
	void step_out ();
	void run_to_position (const gchar *uri, gint line);
	
	void breakpoint_toggle (const gchar *uri, gint line);
	void breakpoint_set (const gchar *uri, gint line);
	void breakpoint_delete (const gchar *uri, gint line);
}

interface IAnjutaVcs
{
	/**
	 * ianjuta_vcs_add:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Add filename to the cvs repositry.
	 */
	void add(const gchar* filename);
	
	/**
	 * ianjuta_cvs_remove:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Remove filename to the cvs repositry. Note that the file
	 * is not removed physicly. This function will fail if the file
	 * still exists on disc.
	 */
	void remove(const gchar* filename);
	
	/**
	 * ianjuta_vcs_update:
	 * @filename: String with the filename
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Update filename with the cvs repositry.
	 */
	void update(const gchar* filename, gboolean recurse);
	
	/**
	 * ianjuta_vcs_commit:
	 * @filename: String with the filename
	 * @log: The log message for the commit or ""
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Commit changes in filename to the cvs repositry.
	 */
	void commit(const gchar* filename, const gchar* log, gboolean recurse);	
}

interface IAnjutaMacro
{
	/**
	 * ianjuta_macro_insert:
	 * @key: Key of the macro
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Insert Macro to editor
	 */
	void insert(const gchar* key);
}

interface IAnjutaSymbol
{
	#include <gdk/gdkpixbuf.h>
	
	enum Type
	{
		TYPE_UNDEF = 0,                // Unknown type
		TYPE_CLASS = 1,                // Class declaration
		TYPE_ENUM = 2,                 // Enum declaration
		TYPE_ENUMERATOR = 4,           // Enumerator value
		TYPE_FIELD = 8,                // Field (Java only)
		TYPE_FUNCTION = 16,            // Function definition
		TYPE_INTERFACE = 32,           // Interface (Java only)
		TYPE_MEMBER = 64,              // Member variable of class/struct
		TYPE_METHOD = 128,             // Class method (Java only)
		TYPE_NAMESPACE = 256,          // Namespace declaration
		TYPE_PACKAGE = 512,            // Package (Java only)
		TYPE_PROTOTYPE = 1024,         // Function prototype
		TYPE_STRUCT = 2048,            // Struct declaration
		TYPE_TYPEDEF = 4096,           // Typedef
		TYPE_UNION = 8192,             // Union
		TYPE_VARIABLE = 16384,         // Variable
		TYPE_EXTERNVAR = 32768,        // Extern or forward declaration
		TYPE_MACRO = 65536,            //  Macro (without arguments)
		TYPE_MACRO_WITH_ARG = 131072,  // Parameterized macro
		TYPE_FILE = 262144,            // File (Pseudo tag)
		TYPE_OTHER = 524288,           // Other (non C/C++/Java tag)
		TYPE_MAX = 1048575             // Maximum value
	}

	// Field masks -- used mainly for search
	enum Field
	{
		FIELD_NONE = 0,                 // Undefined
		FIELD_NAME = 1,                 // Name field
		FIELD_TYPE = 2,                 // Type field
		FIELD_FILE = 4,                 // File field
		FIELD_LINE = 8,                 // Line number field
		FIELD_POSITION = 16,            // Byte pos of symbol (Obsolete)
		FIELD_SCOPE = 32,               // Scope of the symbol field
		FIELD_INHERITANCE = 64,         // Parent classes
		FIELD_ARGUMENTS = 128,          // Argument list
		FIELD_LOCAL = 256,              // If it has local scope
		FIELD_TIME = 512,               // Modification time (File symbol only)
		FIELD_VARTYPE = 1024,           // Variable Type
		FIELD_ACCESS = 2048,            // Access type
		FIELD_IMPLEMENTATION = 4096,    // Implementation (e.g. virtual)
		FIELD_LANGUAGE = 8192,          // Language (File symbols only)
		FIELD_INACTIVE = 16384,         // Inactive file (File symbols only)
		FIELD_POINTER = 32768,          // Inactive file (File symbols only)
		FIELD_MAX = 65535               // Maximum value
	}
	
	// Methods
	Type type ();                // Symbol type
	const gchar *name ();        // Symbol name
	const gchar *args ();        // Args list (functions/prototypes/macros)
	const gchar *scope ();       // Scope of symbol
	const gchar *inheritance (); // Parent classes
	const gchar *var_type ();    // Variable type (maps to struct for typedefs)
	gchar access ();             // Access type (public/protected/private/etc.)
	gchar impl ();               // Implementation (e.g. virtual)
	const gchar *file ();        // File in which the symbol occurs
	gulong line ();              // Line number of the symbol
	gboolean is_local ();        // Is the symbol of local scope
	gboolean is_pointer ();      // Is the symbol Pointer?
	
	GdkPixbuf *icon ();          // Pixbuf icon representing the symbol
}

interface IAnjutaSymbolManager
{
	#include "ianjuta-iterable.h"
	#include "ianjuta-symbol.h"

	// Database query. Returned iterable must be unrefed after use.
	IAnjutaIterable* search (IAnjutaSymbolType match_types, const gchar *match_name, gboolean partial_name_match, gboolean global_search);
	
	// Database query. Returned iterable must be unrefed after use.
	IAnjutaIterable* get_members (const gchar *symbol_name, gboolean global_search);
	IAnjutaIterable* get_parents (const gchar *symbol_name);
}
