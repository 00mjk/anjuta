// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

/**
* IAnjutaFile:
* 
* Implemented by all plugins that can open files.
*/
interface IAnjutaFile
{
	/**
	 * ianjuta_file_open:
	 * @obj: Self
	 * @uri: URI to open.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given URI.
	 */
	void open (const gchar *uri);
	
	/**
	 * ianjuta_file_get_uri:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the URI that was opened with ianjuta_file_open().
	 *
	 * Return value: The last URI opened.
	 */
	gchar* get_uri ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		/**
		 * IAnjutaFileSavable::save_point:
		 * @obj: Self
		 * @entered: TRUE if save point is entered, FALSE otherwise.
		 * 
		 * This signal is emitted when the editor enters or leave the save
		 * point. Save point is the point where the contents were saved to
		 * non-volatile memory (e.g. disk). For example, performing undo/redo
		 * will enter or leave the save point in an editor.
		 */
		void ::save_point (gboolean entered);
		
		/**
		 * IAnjutaFileSavable::saved:
		 * @obj: Self
		 * @uri: URI where the content is saved.
		 * 
		 * This signal is emitted when the content is saved.
		 */
		void ::saved (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_save:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to the original URI from which it was loaded.
		 */
		void save ();
		
		/**
		 * ianjuta_file_savable_save_as:
		 * @obj: Self
		 * @uri: URI to save the content.
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to a different URI.
		 */
		void save_as (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_set_dirty:
		 * @obj: Self
		 * @dirty: 
		 * @err: Error propagation and reporting
		 * 
		 * if @dirty is TRUE, sets dirty for the content. Save point will be
		 * left and the content will be considered not saved. Otherwise,
		 * content will considered saved and save-point will be entered.
		 */
		void set_dirty (gboolean dirty);
		
		/**
		 * ianjuta_file_savable_is_dirty:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Returns the dirty status of the content.
		 *
		 * Return value: TRUE if dirty, FALSE otherwise.
		 */
		gboolean is_dirty ();
	}
}

/** 
* IAnjutaStream:
*
* Stream interface
*/
interface IAnjutaStream
{
	#include <stdio.h>
	
	/**
	 * ianjuta_stream_open:
	 * @obj: Self
	 * @stream: Stream to open from.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given stream.
	 */
	void open (FILE* stream);
	
	interface IAnjutaStreamSavable
	{
		/**
		 * ianjuta_stream_save:
		 * @obj: Self
		 * @stream: Stream to save to.
		 * @err: Error propagation and reporting
		 *
		 * The implementor saves the content to the given stream.
		 */
		void save (FILE* stream);
	}
}

/**
* IAnjutaMarkable:
*
* Markables.
* For example, IAnjutaEditor extension - editor capable of marking lines.
*/
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

	enum Marker
	{
		NONE,
		BASIC,
		LIGHT,
		ATTENTIVE,
		INTENSE
	}

	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	/**
	* ianjuta_markable_unmark:
	* @obj: Self
	* @location: Location where the marker is set.
	* @marker: The marker to unset.
	* @err: Error propagation and reporting
	*
	* Clears the @marker at given @location.
	*/
	void unmark (gint location, Marker marker);
	
	/**
	* ianjuta_markable_is_marker_set:
	* @obj: Self
	* @location: Location to check.
	* @marker: Marker to check.
	* @err: Error propagation and reporting 
	* 
	* Check if the @marker is set at the given @location.
	* 
	* Returns: TRUE if the marker is set at the location, other false.
	*/
	gboolean is_marker_set (gint location, Marker marker);
	
	/**
	* ianjuta_markable_delete_all_markers:
	* @obj: Self
	* @marker: Marker to delete.
	* @err: Error propagation and reporting
	* 
	* Delete the @marker from all locations.
	*/
	void delete_all_markers (Marker marker);
}

interface IAnjutaIndicable
{
	enum Indicator
	{
		NONE,
		IMPORTANT,
		WARNING,
		CRITICAL
	}
	
	void set (gint begin_location, gint end_location, Indicator indicator);
	void clear ();
}

interface IAnjutaIterable
{
	/**
	* ianjuta_iterable_first:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set iter to first element position. Returns FALSE if
	* there is no element in the iterable (hence does not have last).
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean first ();
	
	/**
	* ianjuta_iterable_next:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set the iter position to next element position. Returns FALSE if there
	* is no next element.
	*
	* Returns: TRUE if sucessful, other FALSE..
	*/
	gboolean next ();
	
	/**
	* ianjuta_iterable_previous:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Set the iter position to previous element position. Returns FALSE if
	* there is no previous element.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean previous ();
	
	/**
	* ianjuta_iterable_last:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Set iter position to last element position. Returns FALSE if
	* there is no element in the iterable (hence does not have last).
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean last ();
	
	/**
	* ianjuta_iterable_foreach:
	* @obj: Self
	* @callback: Callback to call for each element.
	* @user_data: user data that is passed back to the callback.
	* @err: Error propagation and reporting
	*
	* Call callback for each element.
	*/
	void foreach (GFunc callback, gpointer user_data);
	
	/**
	* ianjuta_iterable_get:
	* @obj: Self
	* @data_type: Data type of the value being retrieved.
	* @err: Error propagation and reporting
	* 
	* Gets the value at current iter position.
	* Interpretation of 'data' really depends on implementation and is of
	* type 'data_type'. get_nth() gets the element at given position without
	* altering the position of current iter.
	*
	* Returns: The data at current iter position.
	*/
	gpointer get (GType data_type);
	
	/**
	* ianjuta_iterable_get_nth:
	* @obj: Self
	* @data_type: Data type of the value being retrieved.
	* @position: Index of the iter.
	* @err: Error propagation and reporting
	* 
	* Returns the nth element in the list.
	*
	* Returns: The data at nth position.
	*/
	gpointer get_nth (GType data_type, gint position);
	
	/**
	* ianjuta_iterable_get_position:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Index of the current iter in the iterable
	*
	* Returns: integer index.
	*/
	gint get_position ();
	
	/**
	* ianjuta_iterable_get_length:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Length of the iterable
	*
	* Returns: total lenght of the list.
	*/
	gint get_length ();
	
	/**
	* ianjuta_iterable_get_settable:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* If the iterable is settable.
	* 
	* Returns: TRUE if data can be set in this implementation.
	*/
	gboolean get_settable ();
	
	/**
	* ianjuta_iterable_set:
	* @obj: Self
	* @data_type: Data type of the value being set.
	* @data: The data being set.
	* @err: Error propagation and reporting
	* 
	* Sets the value at current iter position. The iterable be be settable.
	* Interpretation of 'data' really depends on implementation. The data
	* must be of type 'data_type'.
	*/
	void set (GType data_type, gpointer data);
	
	/** 
	* ianjuta_iterable_set_nth:
	* @obj: Self
	* @data_type: Data type of the value being set.
	* @data: The data being set.
	* @position: element position where data is set.
	* @err: Error propagation and reporting
	* 
	* Sets the @data at given @position. Current iter position is not altered.
	*/
	void set_nth (GType data_type, gpointer data, gint position);
	
	interface IAnjutaIterableTree
	{
	
		/** 
		* ianjuta_iterable_tree_parent:
		* @obj: Self
		* @err: Error propagation and reporting
		* 
		* Set iter position to parent of curernt iter. If there is no parent,
		* returns FALSE (current iter position is not changed)
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean parent ();
		
		/**
		* ianjuta_iterable_tree_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Iter position set to first child of current iter. If there is no
		* children, return NULL (iter position is not changed).
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean children ();
		
		/**
		* ianjuta_iterable_tree_has_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Returns true if current iter has children
		*
		* Returns: TRUE if there are children, otherwise FALSE.
		*/
		gboolean has_children ();
		
		/**
		* ianjuta_iterable_tree_foreach_post:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		* 
		* Call callback for each element in post order.
		*/
		void foreach_post (GFunc callback, gpointer user_data);
		
		/**
		* ianjuta_iterable_tree_foreach_pre:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		* 
		* Call callback for each element in pre order.
		*/
		void foreach_pre (GFunc callback, gpointer user_data);
	}
}

/**
* IAnjutaBuildable:
*
* Implemented by plugins which can build (e.g module manager plugins).
*/
interface IAnjutaBuildable
{

	/** 
	* ianjuta_buildable_build:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void build (const gchar *uri);
	
	/**
	* ianjuta_buildable_clean:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void clean (const gchar *uri);
	
	/**
	* ianjuta_buildable_install:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void install (const gchar *uri);
	
	/**
	* ianjuta_buildable_configure:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void configure (const gchar *uri);
	
	/**
	* ianjuta_buildable_generate:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void generate (const gchar *uri);
	
	/**
	* ianjuta_buildable_execute:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void execute (const gchar *uri);
}

/**
* IAnjutaProfile:
*
* Studio profile. Like c++ profile, java profile etc.
*/
interface IAnjutaProfile
{
	#include <libanjuta/e-splash.h>
	
	/**
	* ianjuta_profile_load:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* fixme
	*/
	void load ();
}

interface IAnjutaHelp
{

	/**
	* ianjuta_help_search:
	* @obj: Self
	* @query: fixme
	* @err: Error propagation and reporting
	* 
	* fixme
	*/
	void search (const gchar *query);
}

/**
* IAnjutaLoader:
*
* Loaders can deterime correct plugin to open a file or stream.  They
* themselves can not load it, but will correctly redirect the request to
* an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
* IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
* requirements.
*/
interface IAnjutaLoader
{
	/**
	* ianjuta_loader_find_plugins:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Returns all plugins supporting loader interface.
	*/
	GSList * find_plugins ();
	
	/**
	* IAnjutaFileLoader:
	*
	* Loaders can deterime correct plugin to open a file.
	*/
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @uri: URI to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (const gchar *uri, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @uri: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (const gchar *uri);
	}
	
	/**
	* IAnjutaStreamLoader:
	*
	* StreamLoaders can deterime correct plugin to open a stream.
	*/
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	#include <gtk/gtkwidget.h>
	
	enum Error
	{
		DOESNT_EXIST
	}
	
	// Signals.
	
	/**
	 * IAnjutaEditor::char_added:
	 * @position: The position where @ch is added.
	 * @ch: The character that has been added.
	 * @obj: Self
	 * 
	 * This signal is emitted when any character is added inside the editor.
	 * The newly added character is @ch which has been inserted at @position.
	 */
	void   ::char_added (gint position, gchar ch);
	
	/**
	 * IAnjutaEditor::update_ui:
	 * @obj: Self
	 * 
	 * This signal is emitted when the editor assumes the UI must be updated
	 * because some internal state of the editor has changed. For example, if
	 * current line position is changed, it needs to be reflected to the UI.
	 */
	void   ::update_ui ();

	/**
	 * ianjuta_editor_erase_all:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Empties the whole editor buffer. There will be zero characters.
	 */
	void   erase_all ();
	
	/**
	 * ianjuta_editor_insert:
	 * @obj: Self
	 * @position: Character position in editor where insert will take place.
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Inserts @length characters from @text buffer at given @position of
	 * editor buffer. If @length is -1, the whole @text is used.
	 */
	void   insert (int position, const gchar *text, gint length);
	
	/**
	 * ianjuta_editor_append:
	 * @obj: Self
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Appends @length characters from @text buffer at the end of editor
	 * buffer. If @length is -1, the whole @text is used.
	 */
	void   append (const gchar *text, gint length);
	
	/**
	 * ianjuta_editor_goto_line:
	 * @obj: Self
	 * @lineno: line number where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @lineno line and text view is scrolled to
	 * bring it in viewable area of the editor.
	 */
	void   goto_line (gint lineno);
	
	/**
	 * ianjuta_editor_goto_position:
	 * @obj: Self
	 * @position: Character position where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @position and text view is scrolled to
	 * bring @position in viewable area of the editor.
	 */
	void goto_position (gint position);
	
	/**
	 * ianjuta_editor_get_text:
	 * @obj: Self
	 * @start: Begining position
	 * @end: End position
	 * @err: Error propagation and reporting
	 *
	 * Gets the text characters between beginning position and end position
	 * (including themselves). The characters are utf-8 encoded.
	 *
	 * Returns: A buffer of utf-8 characters.
	 * The returned buffer must be freed when no longer required.
	 */
	gchar* get_text (gint start, gint end);
	
	/**
	 * ianjuta_editor_get_attributes:
	 * @obj: Self
	 * @start: Begining position
	 * @end: End position
	 * @err: Error propagation and reporting
	 *
	 * Gets the character attributes for characters between begining
	 * position and end position (including themselves). Character attributes
	 * are really only meaningful in the editor context from which it was
	 * taken. Therefore, the returned data is mainly to be passed back to
	 * the editor.
	 *
	 * Character attributes chould contain display information of the
	 * character, such as font, size, color, highlight information etc.
	 * 
	 * Returns: A buffer of character attributes, indexed in sequence for
	 * characters starting at begining position and ending at end position.
	 * The returned buffer must be freed when no longer required.
	 */
	gchar* get_attributes (gint start, gint end);

	/**
	 * ianjuta_editor_get_position:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Select chars between start and end
	 *
	 * Returns: Current character position since the begining of file.
	 */
	gint   get_position ();
	
	/**
	 * ianjuta_editor_line_from_position:
	 * @obj: Self
	 * @position: Position you want to know the line from
	 * @err: Error propagation and reporting
	 *
	 * Get the line number in which @position locates.
	 * Returns: Line which corresponds to @position
	 *
	 */
	int get_line_from_position (int position);
	
	/**
	 * ianjuta_editor_get_current_pos
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Gets the current position of carat in the text buffer.
	 *
	 */
	void get_current_pos ();
	
	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains current line number on which carat is.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();
	
	/**
	 * ianjuta_editor_get_length:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get length of complete text in editor. This will be the total
	 * number of characters in the file or buffer.
	 *
	 * Return value: Text length.
	 */
	gint   get_length ();
	
	/**
	 * ianjuta_editor_get_current_word:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains the word on which carat is currently on.
	 *
	 * Return value: Current word.
	 */
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_current_column:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current column in the editor.
	 *
	 * Return value: Current column.
	 */
	gint get_column ();
	
	/**
	* ianjuta_editor_get_line_begin_position:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*
	* Returns: fixme
	*/
	gint get_line_begin_position (gint line);
	
	/**
	* ianjuta_editor_get_line_end_position:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	gint get_line_end_position (gint line);
	
	/**
	 * ianjuta_editor_get_overwrite:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains editor overwirte mode: TRUE = Override, FALSE = Insert.
	 *
	 * Return value: editor mode.
	 */
	gboolean get_overwrite ();
	
	/**
	 * ianjuta_editor_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();	
	
	/**
	 * ianjuta_editor_can_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor undo the last operation?
	 *
	 * Returns true if editor can undo, else FALSE
	 */
	gboolean can_undo();
	
	/**
	 * ianjuta_editor_can_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor redo the last operation?
	 *
	 * Returns true if editor can redo, else FALSE
	 */
	gboolean can_redo ();
	
	/**
	 * ianjuta_editor_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Undo last operation
	 */
	void undo ();
	
	/**
	 * ianjuta_editor_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Redo last undo operation
	 */
	void redo ();
	
	/**
	 * ianjuta_editor_set_popup_menu:
	 * @obj: Self
	 * @menu: Popupmenu
	 * @err: Error propagation and reporting
	 *
	 * Set Editor popup menu. This is the menu shown in the editor when one
	 * right-clicks on it.
	 *
	 */
	void set_popup_menu (GtkWidget *menu);
	
	interface IAnjutaEditorSelection
	{
		/**
		 * ianjuta_editor_selection_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets curerntly selected text in editor.
		 * 
		 * Returns: A newly allocated buffer of currently selected characters.
		 * NULL if there is no selection. The returned buffer must be freed after
		 * use.
		 */
		gchar* get ();
		
		/**
		 * ianjuta_editor_selection_set:
		 * @obj: Self
		 * @start: Begin of selection
		 * @end: End of selection
		 * @backward: Direction of search
		 * @err: Error propagation and reporting
		 *
		 * Select characters between start and end
		 */
		void set (gint start, gint end, gboolean backward);
		
		/**
		 * ianjuta_editor_selection_get_start:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets start position of selection text. If there is no selection,
		 * returns the current carat position.
		 *
		 * Return: Start of selection
		 */
		gint get_start ();
		
		/**
		 * ianjuta_editor_selection_get_end:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get end position of selection.
		 */
		gint get_end ();
		
		/**
		 * ianjuta_editor_selection_select_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Selects current block of code. The definition of block of code
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have block concept, in that case this
		 * method does not do anything.
		 */
		void select_block ();
		
		/**
		 * ianjuta_editor_selection_select_function:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select current function block. The definition of function block
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have function concept, in that case this
		 * method does not do anything.
		 */
		void select_function ();

		/**
		 * ianjuta_editor_selection_select_to_brace:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select to brace. Some highlight mode does not have braces concept,
		 * in that case, this method does not do anything.
		 */
		void select_to_brace ();
		
		/**
		 * ianjuta_editor_edit_select_all:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select whole buffer.
		 */
		void select_all ();

		/**
		 * ianjuta_editor_selection_replace:
		 * @obj: Self
		 * @text: Replacement text.
		 * @length: Length of the text to used in @text.
		 * @err: Error propagation and reporting
		 *
		 * Replaces currently selected text with the @text. Only @length amount
		 * of characters are used from @text buffer to replace.
		 */
		void replace (const gchar *text, gint length);
		
		/**
		 * ianjuta_editor_selection_cut:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Cut selection to clipboard.
		 */
		void cut ();
	
		/**
		 * ianjuta_editor_selection_copy:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Copy selection to clipboard.
		 */
		void copy ();
		
		/**
		 * ianjuta_editor_selection_paste:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Paste clipboard at current position.
		 */
		void paste ();
	
		/**
		 * ianjuta_editor_selection_clear:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Clear selection
		 */
		void clear ();
	}
	
	interface IAnjutaEditorConvert
	{
		/**
		 * ianjuta_editor_convert_to_upper:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to uppercase.
		 *
		 */
		void to_upper (gint start_position, gint end_position);
		
		/**
		 * ianjuta_editor_convert_to_lower:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to lowercase
		 *
		 */
		void to_lower (gint start_position, gint end_position);
	}
	
	interface IAnjutaEditorLineMode
	{
		enum Type
		{
			LF,
			CR,
			CRLF
		}
		
		/**
		 * ianjuta_editor_line_mode_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get current line ending mode. It is auto-detected from the
		 * buffer contents.
		 */
		Type get ();
		
		/**
		 * ianjuta_editor_line_mode_set:
		 * @obj: Self
		 * @mode: Line mode to set.
		 * @err: Error propagation and reporting
		 *
		 * Set the line ending mode to the given @mode. All line end
		 * characters in the buffer are converted to @mode characters.
		 */
		void set (Type mode);
		
		/**
		 * ianjuta_editor_line_mode_fix:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Convert EOL characters to majority of line mode. This is helpful
		 * when the buffer contains mixed line modes and we want to fix it.
		 */
		void fix ();
	}
	
	interface IAnjutaEditorAssist
	{
		/**
		 * ianjuta_editor_edit_autocomplete:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Auto complete current word
		 *
		 */
		void autocomplete ();
	}
	
	interface IAnjutaEditorView
	{
		/**
		 * ianjuta_editor_view_open_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open all folds
		 *
		 */
		void open_folds ();
		
		/**
		 * ianjuta_editor_view_close_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Close all folds
		 *
		 */
		void close_folds ();
		
		/**
		 * ianjuta_editor_view_toggle_fold:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open/Close current fold
		 *
		 */
		void toggle_fold ();
	}
}

interface IAnjutaBookmark
{
	/**
	 * ianjuta_bookmark_toggle:
	 * @obj: Self
	 * @location: The location where bookmark is toggled.
	 * @ensure_visible: If the location must be made visible.
	 * @err: Error propagation and reporting
	 *
	 * Toggle bookmark at given @location
	 *
	 */
	void toggle (gint location, gboolean ensure_visible);
	
	/**
	 * ianjuta_bookmark_first:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto first bookmark
	 *
	 */
	void first ();
	
	/**
	 * ianjuta_bookmark_last:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto last bookmark
	 *
	 */
	void last ();
	
	/**
	 * ianjuta_bookmark_next:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto next bookmark
	 *
	 */
	void next ();
	
	/**
	 * ianjuta_bookmark_previous:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto previous bookmark
	 *
	 */
	void previous ();
	
	/**
	 * ianjuta_bookmark_clear_all:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Clear all bookmarks
	 *
	 */
	void clear_all ();
}

interface IAnjutaEditorFactory
{
	#include "ianjuta-editor.h"
	
	/**
	 * ianjuta_editor_factory_new_editor:
	 * @obj: Self
	 * @uri: Uri to open
	 * @filename: filename to open
	 * @err: Error propagation and reporting
	 *
	 * Get a new GtkWidget* which implements IAnjutaEditor
	 *
	 * Return value: An object implementing IAnjutaEditor
	 */
	IAnjutaEditor* new_editor (const gchar* uri, const gchar* filename);
	
	/**
	 * ianjuta_editor_factory_new_style editor:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get a style-editor
	 * FIXME: This is rather stupid and will be removed in the future
	 *
	 * Return value: A style-editor dialog widget
	 */
	gpointer new_style_editor ();
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	/**
	* ianjuta_document_manager_get_full_filename:
	* @obj: Self
	* @file: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme.
	*/
	const gchar * get_full_filename (const gchar *file);
	
	/**
	* ianjuta_document_manager_find_editor_with_path:
	* @obj: Self
	* @file_path: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	IAnjutaEditor* find_editor_with_path (const gchar *file_path);
	
	/**
	* ianjuta_document_manager_goto_file_line:
	* @obj: Self
	* @file: fixme
	* @lineno: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void goto_file_line (const gchar *file, gint lineno);
	
	/** 
	* ianjuta_document_manager_goto_file_line_mark:
	* @obj: Self
	* @file: fixme
	* @lineno: fixme
	* @mark: fixme
	* @err: Error propagation and reporting
	* 
	* fixme
	*/
	void goto_file_line_mark (const gchar *file, gint lineno, gboolean mark);
	
	/**
	* ianjuta_document_manager_get_current_editor:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	IAnjutaEditor* get_current_editor ();
	
	/** 
	* ianjuta_document_manager_set_current_editor:
	* @obj: Self
	* @editor: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void set_current_editor (IAnjutaEditor *editor);
	
	/**
	* ianjuta_document_manager_get_editors:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	GList* get_editors ();

	/**
	* ianjuta_document_manager_add_buffer:
	* @obj: Self
	* @name: fixme
	* @content: fixme
	* @err: Error propagation and reporting.
	* 
	* New editor buffer
	*/
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);
}

interface IAnjutaMessageView
{
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}
	
	/**
	* IAnjutaMessageView::message_clicked:
	* @obj: Self
	* @message: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void ::message_clicked (const gchar *message);
	
	/** 
	* IAnjutaMessageView::buffer_flushed:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::buffer_flushed (const gchar *line);
	
	/**
	* ianjuta_message_view_buffer_append:
	* @obj: Self
	* @text: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void buffer_append (const gchar *text);
	
	/**
	* ianjuta_message_view_append:
	* @obj: Self
	* @type: fixme
	* @summary: fixme
	* @details: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void append (Type type, const gchar *summary, const gchar *details);
	
	/**
	* ianjuta_message_view_clear:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void clear ();
	
	/**
	* ianjuta_message_view_select_next:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void select_next ();
	
	/**
	* ianjuta_message_view_select_previous:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void select_previous ();
	
	/**
	* ianjuta_message_view_get_current_message:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	const gchar* get_current_message ();
	
	/**
	* ianjuta_message_view_get_all_messages:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	GList* get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);
	
	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 */
	void remove_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of 
	 * the notebook or NULL if the message-manager is empty.
	 *
	 * Return value: Current view; #IAnjutaMessageView object.
	 * NULL, if there is no views.
	 */
	IAnjutaMessageView* get_current_view ();
	
	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	
	/**
	 * ianjuta_message_manager_get_all_views:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: A GList* of all views. You must not
	 * manipulate the list.
	 */
	GList* get_all_views ();
	
	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	void set_current_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_set_view_title:
	 * @obj: Self
	 * @view: A message view
	 * @title: Sets the title of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the title of view.
	 *
	 */
	void set_view_title (IAnjutaMessageView *view, const gchar *title);
}

interface IAnjutaFileManager
{

	/**
	* IAnjutaFileManager::section_changed:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::section_changed (const gchar *uri);
	
	/**
	* ianjuta_file_manager_set_root:
	* @obj: Self
	* @root_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void set_root (const gchar *root_uri);
	
	/**
	* ianjuta_file_manager_get_selected:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	gchar* get_selected ();
	
	/**
	* ianjuta_file_manager_set_selected:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme.
	*/
	void set_selected (const gchar *uri);
}

interface IAnjutaTerminal
{
	#include <sys/types.h>
		
	/**
	* ianjuta_terminal_execute_command:
	* @obj: Self
	* @directory: fixme
	* @command: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	* 
	* Returns: fixme
	*/
	pid_t execute_command (const gchar* directory, const gchar *command);
}

interface IAnjutaProjectManager
{
	enum ElementType
	{
		UNKNOWN,
		SOURCE,
		TARGET,
		GROUP
	}
	
	enum TargetType
	{
		TARGET_UNKNOWN,
		TARGET_SHAREDLIB,
		TARGET_STATICLIB,
		TARGET_EXECUTABLE
	}
	
	// Signals
	
	/**
	* IAnjutaProjectManager::element_added:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_added (const gchar *element_uri);
	
	/** 
	* IAnjutaProjectManager::element_removed:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_removed (const gchar *element_uri);
	
	/**
	* IAnjutaProjectManager::element_selected:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_selected (const gchar *element_uri);
	
	// Methods
	
	/**
	* ianjuta_project_manager_get_element_type:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	ElementType get_element_type (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_elements:
	* @obj: Self
	* @element_type: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	GList* get_elements (ElementType element_type);
	
	/**
	* ianjuta_project_manager_get_target_type:
	* @obj: Self
	* @target_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	TargetType get_target_type (const gchar *target_uri);
	
	/**
	* ianjuta_project_manager_get_targets:
	* @obj: Self
	* @target_type: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	GList* get_targets (TargetType target_type);
	
	/**
	* ianjuta_project_manager_get_parent:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gchar* get_parent (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_children:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	GList* get_children (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_selected:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	gchar* get_selected ();
	
	/**
	* ianjuta_project_manager_add_source:
	* @obj: Self
	* @source_uri_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*
	* Returns: element URIs. Must be freed when no longer required.
	*/
	gchar* add_source (const gchar *source_uri_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_add_target:
	* @obj: Self
	* @target_name_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns:
	*/
	gchar* add_target (const gchar *target_name_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_add_group:
	* @obj: Self
	* @group_name_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	gchar* add_group (const gchar *group_name_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_is_open:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/ 
	gboolean is_open ();
}

interface IAnjutaTodo
{

	/**
	* ianjuta_to_do_load:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void load(gchar *uri);
}

interface IAnjutaWizard
{

	/**
	* ianjuta_wizard_activate:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void activate();
}

interface IAnjutaDebuggerManager
{

	/**
	* ianjuta_debugger_manager_is_active:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean is_active ();
	
	/**
	* ianjuta_debugger_manager_is_busy:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean is_busy ();
	
	/**
	* ianjuta_debugger_manager_start:
	* @obj: Self
	* @prog_uri: fixme
	* @source_search_directories: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void start (const gchar *prog_uri, const GList *source_search_directories);
	
	/**
	* ianjuta_debugger_manager_stop:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean stop ();
}

interface IAnjutaDebugger
{
	// Sinals
	
	/**
	* IAnjutaDebugger::busy:
	* @obj: Self
	* @busy_state: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::busy (gboolean busy_state);
	
	/**
	* ianjuta_debugger_is_busy:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean is_busy ();

	/**
	* ianjuta_debugger_load:
	* @obj: Self
	* @prog_uri: fixme
	* @source_search_directories: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void load (const gchar *prog_uri, const GList *source_search_directories);

	/**
	* ianjuta_debugger_run_continue:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void run_continue ();
	
	/**
	* ianjuta_debugger_step_in:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void step_in ();
	
	/**
	* ianjuta_debugger_step_over:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void step_over ();
	
	/**
	* ianjuta_debugger_step_out:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void step_out ();
	
	/**
	* ianjuta_debugger_run_to_position:
	* @obj: Self
	* @uri: fixme
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void run_to_position (const gchar *uri, gint line);
	
	/**
	* ianjuta_debugger_breakpoint_toggle:
	* @obj: Self
	* @uri: fixme
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void breakpoint_toggle (const gchar *uri, gint line);
	
	/**
	* ianjuta_debugger_breakpoint_set:
	* @obj: Self
	* @uri: fixme
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void breakpoint_set (const gchar *uri, gint line);
	
	/**
	* ianjuta_debugger_breakpoint_delete:
	* @obj: Self
	* @uri: fixme
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void breakpoint_delete (const gchar *uri, gint line);
}

interface IAnjutaVcs
{
	/**
	 * ianjuta_vcs_add:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Add filename to the cvs repositry.
	 */
	void add(const gchar* filename);
	
	/**
	 * ianjuta_cvs_remove:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Remove filename to the cvs repositry. Note that the file
	 * is not removed physicly. This function will fail if the file
	 * still exists on disc.
	 */
	void remove(const gchar* filename);
	
	/**
	 * ianjuta_vcs_update:
	 * @filename: String with the filename
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Update filename with the cvs repositry.
	 */
	void update(const gchar* filename, gboolean recurse);
	
	/**
	 * ianjuta_vcs_commit:
	 * @filename: String with the filename
	 * @log: The log message for the commit or ""
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Commit changes in filename to the cvs repositry.
	 */
	void commit(const gchar* filename, const gchar* log, gboolean recurse);	
}

interface IAnjutaMacro
{
	/**
	 * ianjuta_macro_insert:
	 * @key: Key of the macro
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Insert Macro to editor
	 */
	void insert(const gchar* key);
}

interface IAnjutaSymbol
{
	#include <gdk/gdkpixbuf.h>
	
	enum Type
	{
		TYPE_UNDEF = 0,                // Unknown type
		TYPE_CLASS = 1,                // Class declaration
		TYPE_ENUM = 2,                 // Enum declaration
		TYPE_ENUMERATOR = 4,           // Enumerator value
		TYPE_FIELD = 8,                // Field (Java only)
		TYPE_FUNCTION = 16,            // Function definition
		TYPE_INTERFACE = 32,           // Interface (Java only)
		TYPE_MEMBER = 64,              // Member variable of class/struct
		TYPE_METHOD = 128,             // Class method (Java only)
		TYPE_NAMESPACE = 256,          // Namespace declaration
		TYPE_PACKAGE = 512,            // Package (Java only)
		TYPE_PROTOTYPE = 1024,         // Function prototype
		TYPE_STRUCT = 2048,            // Struct declaration
		TYPE_TYPEDEF = 4096,           // Typedef
		TYPE_UNION = 8192,             // Union
		TYPE_VARIABLE = 16384,         // Variable
		TYPE_EXTERNVAR = 32768,        // Extern or forward declaration
		TYPE_MACRO = 65536,            //  Macro (without arguments)
		TYPE_MACRO_WITH_ARG = 131072,  // Parameterized macro
		TYPE_FILE = 262144,            // File (Pseudo tag)
		TYPE_OTHER = 524288,           // Other (non C/C++/Java tag)
		TYPE_MAX = 1048575             // Maximum value
	}

	// Field masks -- used mainly for search
	enum Field
	{
		FIELD_NONE = 0,                 // Undefined
		FIELD_NAME = 1,                 // Name field
		FIELD_TYPE = 2,                 // Type field
		FIELD_FILE = 4,                 // File field
		FIELD_LINE = 8,                 // Line number field
		FIELD_POSITION = 16,            // Byte pos of symbol (Obsolete)
		FIELD_SCOPE = 32,               // Scope of the symbol field
		FIELD_INHERITANCE = 64,         // Parent classes
		FIELD_ARGUMENTS = 128,          // Argument list
		FIELD_LOCAL = 256,              // If it has local scope
		FIELD_TIME = 512,               // Modification time (File symbol only)
		FIELD_VARTYPE = 1024,           // Variable Type
		FIELD_ACCESS = 2048,            // Access type
		FIELD_IMPLEMENTATION = 4096,    // Implementation (e.g. virtual)
		FIELD_LANGUAGE = 8192,          // Language (File symbols only)
		FIELD_INACTIVE = 16384,         // Inactive file (File symbols only)
		FIELD_POINTER = 32768,          // Inactive file (File symbols only)
		FIELD_MAX = 65535               // Maximum value
	}
	
	// Methods
	Type type ();                // Symbol type
	const gchar *name ();        // Symbol name
	const gchar *args ();        // Args list (functions/prototypes/macros)
	const gchar *scope ();       // Scope of symbol
	const gchar *inheritance (); // Parent classes
	const gchar *var_type ();    // Variable type (maps to struct for typedefs)
	gchar access ();             // Access type (public/protected/private/etc.)
	gchar impl ();               // Implementation (e.g. virtual)
	const gchar *file ();        // File in which the symbol occurs
	gulong line ();              // Line number of the symbol
	gboolean is_local ();        // Is the symbol of local scope
	guint pointer_order ();      // The number of pointer signs
	
	GdkPixbuf *icon ();          // Pixbuf icon representing the symbol
}

interface IAnjutaSymbolManager
{
	#include "ianjuta-iterable.h"
	#include "ianjuta-symbol.h"

	/**
	* ianjuta_symbol_manager_search:
	* @obj: Self
	* @match_types: fixme
	* @match_name: fixme
	* @partial_name_match: fixme
	* @global_search: fixme
	* @err: Error propagation and reporting.
	* 
	* Database query. Returned iterable must be unrefed after use.
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* search (IAnjutaSymbolType match_types, const gchar *match_name, gboolean partial_name_match, gboolean global_search);
	
	/**
	* ianjuta_symbol_manager_get_members:
	* @obj: Self
	* @symbol_name: fixme
	* @global_search: fixme
	* @err: Error propagation and reporting.
	* 
	* Database query. Returned iterable must be unrefed after use.
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* get_members (const gchar *symbol_name, gboolean global_search);
	
	/**
	* ianjuta_symbol_manager_get_parents:
	* @obj: Self
	* @symbol_name: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* get_parents (const gchar *symbol_name);
}
