// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

// Implemented by all plugins that can open files
interface IAnjutaFile
{
	void open (const gchar *uri);
	gchar* get_uri ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		void ::save_point (gboolean entered);
		void ::saved (const gchar *uri);
		
		void save ();
		void save_as (const gchar *uri);
		
		void set_dirty (gboolean dirty);
		gboolean is_dirty ();
	}
}

// Stream interface
interface IAnjutaStream
{
	#include <stdio.h>
	
	void open (FILE *stream);
	
	interface IAnjutaStreamSavable
	{
		void save (FILE *stream);
	}
}

// Markables.
// For example, IAnjutaEditor extension - editor capable of marking lines
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

	enum Marker
	{
		NONE,
		BASIC,
		LIGHT,
		ATTENTIVE,
		INTENSE
	}

	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	void unmark (gint location, Marker marker);
	gboolean is_marker_set (gint location, Marker marker);
	void delete_all_markers (Marker marker);
}

// Sandbox gives restricted and localized access to the implementation
interface IAnjutaSandBox
{
	enum Error
	{
		ACCESS_VIOLATION
	}
	
	// Invokers wishing to pass the box down to others, should lock
	// their current box. lock_signature is just a unique key to
	// protect invoker's box and only a matching lock_signature with the last
	// push lock can pop open a lock, otherwise ACCESS_VIOLATION error will
	// be thrown.
	void push_lock (gpointer lock_signature);
	void pop_lock (gpointer lock_signature);
	
	// Contexts are, well, contexts. Interesting things happen in contexts.
	interface IAnjutaContext
	{
		// Contexts can only be begun or ended while the lock stack is
		// empty. It basically means only the owner of this context can call
		// these, presumably to initialize or finalize the context. Any other
		// invoker trying to call them (that is, lock stack is not empty),
		// will result in ACCESS_VIOLATION error.
		void begin();
		void end();
		
		// Clears current level. That is, anything done since last push_lock
		// is cleared and context state restored to just after the push.
		void clear();
		
		// Text context represents a hierarchially indented
		// text. Each call to push_lock starts a level and automatically
		// indents subsequent render texts to that level.
		interface IAnjutaContextText
		{
			// Sets indentation level. Indentations should be stacked for
			// each level, because they might have different indentation sizes.
			void set_indentation (gint spaces);
			
			// Returns current level's indentation in space. Presumably to 
			// do some calculations before rendering a text.
			gint get_indentation ();
			
			// renders the text.
			void render (const gchar *text);
		}

		// Tree context represents a hierarchial tree. Each render() renders
		// a tree node. down() takes it down one level and up() takes it to the
		// parent node. Note that tree depths are not equivalent to context
		// levels. A context level might consist of many tree depths.
		interface IAnjutaContextList
		{
			#include <gdk/gdkpixbuf.h>
			
			enum Size
			{
				MINI,
				SMALL,
				LARGE
			}
			
			// Sets the size of the context.
			void set_size (Size size);
			
			// Gets the size of the context.
			Size get_size ();
			
			// Renders a mini view.
			void render (GdkPixbuf *image, const gchar *text, GValue* data);
			
			// Tree context represents a hierarchial tree. Each render() renders
			// a tree node. down() takes it down one level and up() takes it to the
			// parent node. Note that tree depths are not equivalent to context
			// levels. A context level might consist of many tree depths.
			interface IAnjutaContextTree
			{
				void down ();
				void up ();
			}
		}
	}
}

// Implemented by plugins which can render itself
interface IAnjutaRenderable
{
	#include "ianjuta-context.h"
	
	enum Error
	{
		NOT_SUPPORTED
	}
	// Render itself in the given context. Note that the renderable should
	// automatically determine the type of context and render accordingly.
	// It also means the context implementor should really not implement
	// more than one context type, avoiding ambiguity in renderable.
	void render (IAnjutaContext *context);
}

interface IAnjutaIterable
{
	enum Error
	{
		INVALID_ITER,
		UNSETTABLE,
	}
	
	// Implementation dependent data to store iter info. Should
	// not be used by the invoker.
	struct Iter
	{
		gpointer a;
		gpointer b;
		gpointer c;
		gpointer d;
		gpointer e;
	}
	
	// Iter at begining
	Iter* begin ();
	
	// iter at end
	Iter* end ();
	
	// Copy iter
	Iter* copy (Iter *iter);
	
	// iters returned by begin(), end() and copy must be freeed with this
	void free_iter (Iter *iter);
	
	// Resets the iter to the begining
	void reset (Iter *iter);
	
	// If the iter value is settable
	gboolean get_settable ();
	
	// Forwards the iter. In recursable, it will desent into first node
	// if current iter has children.
	void next (Iter* iter);
	
	// Reverse the iter. In recursable, it will come up the parent node
	// if current iter is first child.
	void previous (Iter* iter);
	
	// Call callback for each iter starting from given iter.
	// Give NULL iter to call for all nodes
	void foreach (Iter* start_iter, GCallback *callback, gpointer user_dat);
	
	// Interpretation of 'data' really depends on implementation
	gpointer get (Iter *iter);
	void set (Iter *iter, gpointer data);
	
	// Checks if the iter is valid
	gboolean valid (Iter* iter);
	
	interface IAnjutaIterableTree
	{
		// Set iter to parent
		void parent (Iter *iter);
		
		// Get first child
		Iter* get_children (Iter *ter);
		
		gboolean has_children (Iter *iter);
	}
}

// Implemented by plugins which can transform it's data into some output.
interface IAnjutaTransformable
{
	void transform();
}

// Implemented by plugins which can build (e.g module manager plugins).
interface IAnjutaBuildable
{
	void compile (const gchar* filename);
	void build (const gchar *directory);
	void clean (const gchar *directory);
	void install (const gchar *directory);
	void configure (const gchar *directory);
	void generate(const gchar *directory);
}

// Studio profile. Like c++ profile, java profiler etc.
interface IAnjutaProfile
{
	#include <libanjuta/e-splash.h>
	
	void load(ESplash *splash);
}

interface IAnjutaHelp
{
	void search (const gchar *query);
}

// Loaders can deterime correct plugin to open a file or stream.  They
// themselves can not load it, but will correctly redirect the request to
// an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
// IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
// requirements.
interface IAnjutaLoader
{
	// Returns all plugins supporting loader interface.
	GSList * find_plugins ();
	
	// Loaders can deterime correct plugin to open a file
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @uri: URI to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (const gchar *uri, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @uri: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (const gchar *uri);
	}
	
	// StreamLoaders can deterime correct plugin to open a stream.
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	enum Error
	{
		DOESNT_EXIST
	}
	
	// Signals.
	void   ::char_added (gint position, gchar ch);
	void   ::update_ui ();
	
	void   insert (int position, const gchar *text, gint length);
	void   goto_line (gint lineno);
	void   goto_position (gint position);
	gchar* get_selection ();
	gchar* get_text (gint start, gint end);
	gchar* get_attributes (gint start, gint end);
	gint   get_position ();

	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current line in the editor.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();

	gint   get_length ();
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	const gchar * get_full_filename (const gchar *file);
	IAnjutaEditor* find_editor_with_path (const gchar *file_path);
	void goto_file_line (const gchar *file, gint lineno);
	void goto_file_line_mark (const gchar *file, gint lineno, gboolean mark);
	IAnjutaEditor* get_current_editor ();
	void set_current_editor (IAnjutaEditor *editor);
	GList* get_editors ();

	// New editor buffer
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);
}

interface IAnjutaMessageView
{
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}
	
	// Signals
	void ::message_clicked (const gchar *message);
	void ::buffer_flushed (const gchar *line);
	
	/* Buffer methods */
	void buffer_append (const gchar *text);
	void append (Type type, const gchar *summary, const gchar *details);
	void clear ();
	void select_next ();
	void select_previous ();
	const gchar* get_current_message ();
	GList* get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	 
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);
	
	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 *
	 */
	
	void remove_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of 
	 * the notebook or NULL if the message-manager is empty.
	 */
	 
	IAnjutaMessageView* get_current_view ();
	
	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	 
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	
	/**
	 * ianjuta_message_manager_get_all_views:
	 * @name: Name of the view you want to get
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: A GList* of all views. You must not
	 * manipulate the list.
	 */
	
	GList* get_all_views ();
	
	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	
	void set_current_view (IAnjutaMessageView *view);
}

interface IAnjutaFileManager
{
	void ::section_changed (const gchar *uri);
	
	void set_root (const gchar *root_uri);
	gchar* get_selected ();
	void set_selected (const gchar *uri);
}

/* interface IAnjutaLauncher
 * {
 * 	#include <sys/types.h>
 * 	
 * 	void ::child_exited (pid_t child_pid, int exit_status, gulong time_taken_in_secs);
 * 	void ::busy_signal (gboolean busy_flag);
 * 
 * 	gboolean is_busy ();
 * 	gboolean execute (const gchar *command, GCallback callback_func, gpointer user_data);
 * 	gboolean execute_v (gchar *const argv[], GCallback callback_func, gpointer user_data);
 * 	void set_encoding (const gchar *charset);
 * 	void send_stdin (const gchar *input_data);
 * 	void send_ptyin (const gchar *input_data);
 * 	pid_t get_child_pid ();
 * 	void reset ();
 * 	void signal (int sig);
 * 	void set_buffered_output (gboolean buffered);
 * 	void set_check_passwd_prompt (gboolean buffered);
 * 	gboolean set_terminal_echo (gboolean echo_on);
 * }
 * 
 */
interface IAnjutaTerminal
{
	#include <sys/types.h>
	pid_t execute_command (const gchar *command);
}

interface IAnjutaProjectManager
{
	void configure();
}

interface IAnjutaTodo
{
	void load(gchar *uri);
}

interface IAnjutaWizard
{
	void activate();
}

/* interface IAnjutaModule
 * {
 * }
 * 
 * // Implemented by plugins which can manage something
 * interface IAnjutaManager
 * {
 * 	GValue* get (const gchar *key);
 * 	void set (const gchar *key, GValue *value);
 * 	
 * 	// Implemented by plugins which can manage metafiles
 * 	interface IAnjutaMataManager
 * 	{
 * 		gchar* get_name ();
 * 	
 * 		interface IAnjutaProjectManager
 * 		{
 * 			void configure();
 * 		}
 * 		
 * 		interface IAnjutaModuleManager
 * 		{
 * 			void ::file_added (const gchar *filename);
 * 			void ::module_added (const gchar *module_name);
 * 			
 * 			void add_file (const gchar *filename);
 * 			void remove_file (const gchar *filename);
 * 			
 * 			gchar* get_path (const gchar *filename);
 * 			
 * 			interface IAnjutaModuleSource
 * 			{
 * 				void ::target_added (const gchar *target);
 * 				
 * 				enum TargetType
 * 				{
 * 					SLIB,
 * 					DLIB,
 * 					BIN,
 * 					EXTRA
 * 				}
 * 				void add_target (const gchar *target_name);
 * 				void remove_target (const gchar *target_name);
 * 			}
 * 		}
 * 	}
 * }
 */

interface IAnjutaDebuggerManager
{
	gboolean is_debugger_active ();

	void toggle_breakpoint (gint line);
}

interface IAnjutaDebugger
{
	gboolean is_active ();

	void start (const gchar *prog);
	void load_executable (const gchar *prog);
	void load_core (const gchar *core);

	void run_continue ();
	void step_in ();
	void step_over ();
	void step_out ();

	void toggle_breakpoint1 (gint line);

	/* TODO: remove this function after moving UI to debug-manager */
	void toggle_breakpoint ();
}
