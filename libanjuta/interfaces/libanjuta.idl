// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

/**
* IAnjutaFile:
* 
* Implemented by all plugins that can open files.
*/
interface IAnjutaFile
{
	/**
	 * ianjuta_file_open:
	 * @obj: Self
	 * @uri: URI to open.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given URI.
	 */
	void open (const gchar *uri);
	
	/**
	 * ianjuta_file_get_uri:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the URI that was opened with ianjuta_file_open().
	 *
	 * Return value: The last URI opened.
	 */
	gchar* get_uri ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		/**
		 * IAnjutaFileSavable::save_point:
		 * @obj: Self
		 * @entered: TRUE if save point is entered, FALSE otherwise.
		 * 
		 * This signal is emitted when the editor enters or leave the save
		 * point. Save point is the point where the contents were saved to
		 * non-volatile memory (e.g. disk). For example, performing undo/redo
		 * will enter or leave the save point in an editor.
		 */
		void ::save_point (gboolean entered);
		
		/**
		 * IAnjutaFileSavable::saved:
		 * @obj: Self
		 * @uri: URI where the content is saved.
		 * 
		 * This signal is emitted when the content is saved.
		 */
		void ::saved (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_save:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to the original URI from which it was loaded.
		 */
		void save ();
		
		/**
		 * ianjuta_file_savable_save_as:
		 * @obj: Self
		 * @uri: URI to save the content.
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to a different URI.
		 */
		void save_as (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_set_dirty:
		 * @obj: Self
		 * @dirty: 
		 * @err: Error propagation and reporting
		 * 
		 * if @dirty is TRUE, sets dirty for the content. Save point will be
		 * left and the content will be considered not saved. Otherwise,
		 * content will considered saved and save-point will be entered.
		 */
		void set_dirty (gboolean dirty);
		
		/**
		 * ianjuta_file_savable_is_dirty:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Returns the dirty status of the content.
		 *
		 * Return value: TRUE if dirty, FALSE otherwise.
		 */
		gboolean is_dirty ();
	}
}

/** 
* IAnjutaStream:
*
* Stream interface
*/
interface IAnjutaStream
{
	#include <stdio.h>
	
	/**
	 * ianjuta_stream_open:
	 * @obj: Self
	 * @stream: Stream to open from.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given stream.
	 */
	void open (FILE* stream);
	
	interface IAnjutaStreamSavable
	{
		/**
		 * ianjuta_stream_save:
		 * @obj: Self
		 * @stream: Stream to save to.
		 * @err: Error propagation and reporting
		 *
		 * The implementor saves the content to the given stream.
		 */
		void save (FILE* stream);
	}
}

/**
* IAnjutaMarkable:
*
* Markables.
* For example, IAnjutaEditor extension - editor capable of marking lines.
*/
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

	enum Marker
	{
		LINEMARKER,
		BOOKMARK,
		BREAKPOINT_DISABLED,
		BREAKPOINT_ENABLED,
		PROGRAM_COUNTER
	}

	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	/**
	* ianjuta_markable_unmark:
	* @obj: Self
	* @location: Location where the marker is set.
	* @marker: The marker to unset.
	* @err: Error propagation and reporting
	*
	* Clears the @marker at given @location.
	*/
	void unmark (gint location, Marker marker);
	
	/**
	* ianjuta_markable_is_marker_set:
	* @obj: Self
	* @location: Location to check.
	* @marker: Marker to check.
	* @err: Error propagation and reporting 
	* 
	* Check if the @marker is set at the given @location.
	* 
	* Returns: TRUE if the marker is set at the location, other false.
	*/
	gboolean is_marker_set (gint location, Marker marker);
	
	/**
	* ianjuta_markable_delete_all_markers:
	* @obj: Self
	* @marker: Marker to delete.
	* @err: Error propagation and reporting
	* 
	* Delete the @marker from all locations.
	*/
	void delete_all_markers (Marker marker);
}

interface IAnjutaIndicable
{
	enum Indicator
	{
		NONE,
		IMPORTANT,
		WARNING,
		CRITICAL
	}
	
	void set (gint begin_location, gint end_location, Indicator indicator);
	void clear ();
}

interface IAnjutaIterable
{
	/**
	* ianjuta_iterable_first:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set iter to first element position. Returns FALSE if
	* there is no element in the iterable (hence does not have first).
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean first ();
	
	/**
	* ianjuta_iterable_next:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set the iter position to next element position. Returns FALSE if there
	* is no next element and the iter remains pointed to the last element.
	*
	* Returns: TRUE if sucessful, other FALSE..
	*/
	gboolean next ();
	
	/**
	* ianjuta_iterable_previous:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Set the iter position to previous element position. Returns FALSE if
	* there is no previous element and the iter remains pointed to the first
	* element.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean previous ();
	
	/**
	* ianjuta_iterable_last:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Set iter position to last element position. Returns FALSE if
	* there is no element in the iterable (hence does not have last).
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean last ();
	
	/**
	* ianjuta_iterable_foreach:
	* @obj: Self
	* @callback: Callback to call for each element.
	* @user_data: user data that is passed back to the callback.
	* @err: Error propagation and reporting
	*
	* Call callback for each element in the list. Call back is passed the
	* same iter, but with different position set (from first to last). This
	* method does not affect current position. i.e. current position is
	* restored at the end of this method.
	*/
	void foreach (GFunc callback, gpointer user_data);
	
	/**
	* ianjuta_iterable_set_position:
	* @obj: Self
	* @position: New position for the iter.
	* @err: Error propagation and reporting
	* 
	* Sets the current position of the iter to @position. The given @position
	* must be from 0 to length - 1 (ianjuta_iter_get_length()), otherwise
	* FLASE will be returned. If invalid iter @position is given, the current
	* iter position is not altered.
	*
	* Returns: TRUE if successfully set (i.e. @position is within the range).
	* otherwise returns FALSE (i.e. @position is out of data range).
	*/
	gboolean set_position (gint position);
	
	/**
	* ianjuta_iterable_get_position:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Index of the current iter in the iterable. It will be
	* from 0 to length - 1 (ianjuta_iter_get_length())
	*
	* Returns: integer index.
	*/
	gint get_position ();

	/**
	* ianjuta_iterable_get_length:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Length of the iterable
	*
	* Returns: total length of the list.
	*/
	gint get_length ();

	/**
	* ianjuta_iterable_clone:
	* @obj: Self
	* @err: Error propagation and reporting
	* 
	* Clones the iterable. The returned iterable object must be unrefed
	* when done.
	*
	* Returns: A new instance of this iterable pointing at the same location.
	*/
	IAnjutaIterable *clone ();

	/**
	* ianjuta_iterable_assign:
	* @obj: Self
	* @src_iter: Source iter from which to copy the assignment.
	* @err: Error propagation and reporting
	* 
	* Assigns the iter position from @src_iter.
	*
	*/
	void assign (IAnjutaIterable *src_iter);

	interface IAnjutaIterableTree
	{
	
		/** 
		* ianjuta_iterable_tree_parent:
		* @obj: Self
		* @err: Error propagation and reporting
		* 
		* Set iter position to parent of curernt iter. If there is no parent,
		* returns FALSE (current iter position is not changed)
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean parent ();
		
		/**
		* ianjuta_iterable_tree_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Iter position set to first child of current iter. If there is no
		* children, return NULL (iter position is not changed).
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean children ();
		
		/**
		* ianjuta_iterable_tree_has_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Returns true if current iter has children
		*
		* Returns: TRUE if there are children, otherwise FALSE.
		*/
		gboolean has_children ();
		
		/**
		* ianjuta_iterable_tree_foreach_post:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		* 
		* Call callback for each element in post order.
		*/
		void foreach_post (GFunc callback, gpointer user_data);
		
		/**
		* ianjuta_iterable_tree_foreach_pre:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		* 
		* Call callback for each element in pre order.
		*/
		void foreach_pre (GFunc callback, gpointer user_data);
	}
}

/**
* IAnjutaBuildable:
*
* Implemented by plugins which can build (e.g module manager plugins).
*/
interface IAnjutaBuildable
{

	/** 
	* ianjuta_buildable_build:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void build (const gchar *uri);
	
	/**
	* ianjuta_buildable_clean:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void clean (const gchar *uri);
	
	/**
	* ianjuta_buildable_install:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void install (const gchar *uri);
	
	/**
	* ianjuta_buildable_configure:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void configure (const gchar *uri);
	
	/**
	* ianjuta_buildable_generate:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void generate (const gchar *uri);
	
	/**
	* ianjuta_buildable_execute:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void execute (const gchar *uri);
}

/**
* IAnjutaProfile:
*
* Studio profile. Like c++ profile, java profile etc.
*/
interface IAnjutaProfile
{
	/* #include <libanjuta/e-splash.h>*/
	
	/**
	* ianjuta_profile_load:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Load the default profile
	*/
	void load ();
}

interface IAnjutaHelp
{

	/**
	* ianjuta_help_search:
	* @obj: Self
	* @query: fixme
	* @err: Error propagation and reporting
	* 
	* fixme
	*/
	void search (const gchar *query);
}

/**
* IAnjutaLoader:
*
* Loaders can deterime correct plugin to open a file or stream.  They
* themselves can not load it, but will correctly redirect the request to
* an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
* IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
* requirements.
*/
interface IAnjutaLoader
{
	#include <libanjuta/anjuta-plugin.h>
	/**
	* ianjuta_loader_find_plugins:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Returns all plugins supporting loader interface.
	*/
	List<AnjutaPlugin*> find_plugins ();
	
	/**
	* IAnjutaFileLoader:
	*
	* Loaders can deterime correct plugin to open a file.
	*/
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @uri: URI to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (const gchar *uri, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @uri: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (const gchar *uri);
	}
	
	/**
	* IAnjutaStreamLoader:
	*
	* StreamLoaders can deterime correct plugin to open a stream.
	*/
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	#include <gtk/gtkwidget.h>
	#include <libanjuta/interfaces/ianjuta-iterable.h>
	
	enum Error
	{
		DOESNT_EXIST
	}
	
	enum Attribute
	{
		TEXT,
		KEYWORD,
		COMMENT,
		STRING
	}
	
	// Signals.
	
	/**
	 * IAnjutaEditor::char_added:
	 * @position: The position where @ch is added.
	 * @ch: The character that has been added.
	 * @obj: Self
	 * 
	 * This signal is emitted when any character is added inside the editor.
	 * The newly added character is @ch which has been inserted at @position.
	 */
	void   ::char_added (gint position, gchar ch);
	
	/**
	 * IAnjutaEditor::changed:
	 * @position: The position where change happend.
	 * @added: TRUE if added, FALSE if deleted.
	 * @length: Length of the text changed.
	 * @lines: Number of lines added or removed.
	 * @text: The text added or removed.
	 * @obj: Self
	 * 
	 * This signal is emitted when any text change happens in editor.
	 * The changes begin at @position. @text is not garanteed to be NULL
	 * terminated. Use @length to read the text. @lines represent the
	 * number of line breaks in the added or removed text.
	 */
	void   ::changed (gint position, gboolean added, gint length, gint lines, const gchar *text);
	
	/**
	 * IAnjutaEditor::update_ui:
	 * @obj: Self
	 * 
	 * This signal is emitted when the editor assumes the UI must be updated
	 * because some internal state of the editor has changed. For example, if
	 * current line position is changed, it needs to be reflected to the UI.
	 */
	void   ::update_ui ();

	/**
	 * ianjuta_editor_grab_focus:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Grabs the focus.
	 */
	void   grab_focus ();
	
	/**
	 * ianjuta_editor_get_tabsize:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the tabsize (in spaces) currently used by the editor.
	 *
	 * Returns: tabsize in number of spaces
	 */
	gint   get_tabsize ();
	
	/**
	 * ianjuta_editor_set_tabsize:
	 * @obj: Self
	 * @tabsize: Tabsize in spaces
	 * @err: Error propagation and reporting
	 *
	 * Sets the tabsize of the editor.
	 */
	void   set_tabsize (gint tabsize);
	
	/**
	 * ianjuta_editor_get_use_spaces:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns if the editor uses spaces for filling up tab characters.
	 *
	 * Returns: TRUE if yes, FALSE if no.
	 */
	gboolean   get_use_spaces ();
	
	/**
	 * ianjuta_editor_set_use_space:
	 * @obj: Self
	 * @use_spaces: TRUE to use spaces, FALSE to use tab char directly.
	 * @err: Error propagation and reporting
	 *
	 * Sets if the editor should use spaces for filling up tab characters.
	 */
	void   set_use_spaces (gboolean use_spaces);
	
	/**
	 * ianjuta_editor_set_auto_indent:
	 * @obj: Self
	 * @auto_indent: TRUE to enable auto-indent, FALSE to disable
	 *
	 * Sets whether the editor should auto-indent itself. A plugin that does
	 * custom auto-indent can set this to false and override the preferences
	 * setting
	 */
	void set_auto_indent(gboolean auto_indent);
	
	/**
	 * ianjuta_editor_erase:
	 * @obj: Self
	 * @position: Start position of chars to erase. Must be 0 or more.
	 * @length: number of chars to erase. -1 means till the end of document.
	 * @err: Error propagation and reporting
	 *
	 * Erases the @length number of chars starting from @position. If length
	 * is 0, nothing happens.
	 */
	void   erase (gint position, gint length);
	
	/**
	 * ianjuta_editor_erase_all:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Empties the whole editor buffer. There will be zero characters.
	 */
	void   erase_all ();
	
	/**
	 * ianjuta_editor_insert:
	 * @obj: Self
	 * @position: Character position in editor where insert will take place.
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Inserts @length characters from @text buffer at given @position of
	 * editor buffer. If @length is -1, the whole @text is used.
	 */
	void   insert (int position, const gchar *text, gint length);
	
	/**
	 * ianjuta_editor_append:
	 * @obj: Self
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Appends @length characters from @text buffer at the end of editor
	 * buffer. If @length is -1, the whole @text is used.
	 */
	void   append (const gchar *text, gint length);
	
	/**
	 * ianjuta_editor_goto_line:
	 * @obj: Self
	 * @lineno: line number where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @lineno line and text view is scrolled to
	 * bring it in viewable area of the editor.
	 */
	void   goto_line (gint lineno);
	
	/**
	 * ianjuta_editor_goto_position:
	 * @obj: Self
	 * @position: Character position where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @position and text view is scrolled to
	 * bring @position in viewable area of the editor.
	 */
	void goto_position (gint position);
	
	/**
	 * ianjuta_editor_get_text:
	 * @obj: Self
	 * @position: Begining position. Must be greater than or equal to 0.
	 * @length: length of the text. -1 means till the end of document.
	 * @err: Error propagation and reporting
	 *
	 * Gets @length text characters beginning from @position
	 * (including char pointed by @position). If @length is less then
	 * 0 or exceeds document length, text till the end of the document is
	 * returned. @start must be 0 or greater then 0. If @start is beyond
	 * document length, NULL is returned. If @length is 0, NULL is returned.
	 * The characters returned are utf-8 encoded.
	 *
	 * Returns: A buffer of utf-8 characters.
	 * The returned buffer must be freed when no longer required.
	 */
	gchar* get_text (gint position, gint length);
	
	/**
	 * ianjuta_editor_get_attributes:
	 * @obj: Self
	 * @start: Begining position
	 * @end: End position
	 * @err: Error propagation and reporting
	 *
	 * Gets the character attributes for characters between begining
	 * position and end position (including themselves). Character attributes
	 * are really only meaningful in the editor context from which it was
	 * taken. Therefore, the returned data is mainly to be passed back to
	 * the editor.
	 *
	 * Character attributes chould contain display information of the
	 * character, such as font, size, color, highlight information etc.
	 * 
	 * Returns: A buffer of character attributes, indexed in sequence for
	 * characters starting at begining position and ending at end position.
	 * The returned buffer must be freed when no longer required.
	 */
	Attribute* get_attributes (gint start, gint length);

	/*
	 * ianjuta_editor_get_position:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get current caret position
	 *
	 * Returns: Current character position since the begining of file.
	 */
	gint   get_position ();
	
	/**
	 * ianjuta_editor_line_from_position:
	 * @obj: Self
	 * @position: Position you want to know the line from
	 * @err: Error propagation and reporting
	 *
	 * Get the line number in which @position locates.
	 * Returns: Line which corresponds to @position
	 *
	 */
	int get_line_from_position (int position);
	
	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains current line number on which carat is.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();
	
	/**
	 * ianjuta_editor_get_length:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get length of complete text in editor. This will be the total
	 * number of characters in the file or buffer.
	 *
	 * Return value: Text length.
	 */
	gint   get_length ();
	
	/**
	 * ianjuta_editor_get_current_word:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains the word on which carat is currently on.
	 *
	 * Return value: Current word.
	 */
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_current_column:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current column in the editor.
	 *
	 * Return value: Current column.
	 */
	gint get_column ();
	
	/**
	* ianjuta_editor_get_line_begin_position:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*
	* Returns: fixme
	*/
	gint get_line_begin_position (gint line);
	
	/**
	* ianjuta_editor_get_line_end_position:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	gint get_line_end_position (gint line);
	
	/**
	 * ianjuta_editor_get_overwrite:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains editor overwirte mode: TRUE = Override, FALSE = Insert.
	 *
	 * Return value: editor mode.
	 */
	gboolean get_overwrite ();
	
	/**
	 * ianjuta_editor_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();	
	
	/**
	 * ianjuta_editor_can_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor undo the last operation?
	 *
	 * Returns true if editor can undo, else FALSE
	 */
	gboolean can_undo();
	
	/**
	 * ianjuta_editor_can_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor redo the last operation?
	 *
	 * Returns true if editor can redo, else FALSE
	 */
	gboolean can_redo ();
	
	/**
	 * ianjuta_editor_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Undo last operation
	 */
	void undo ();
	
	/**
	 * ianjuta_editor_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Redo last undo operation
	 */
	void redo ();

	/**
	 * ianjuta_editor_begin_undo_action:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Begins the mark of undoable action. Calls to this are stacked and
	 * each must be ended with ianjuta_editor_end_action().
	 */
	void begin_undo_action ();
	
	/**
	 * ianjuta_editor_end_undo_action:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Ends the mark of undoable action.
	 */
	void end_undo_action ();

	/**
	 * ianjuta_editor_set_popup_menu:
	 * @obj: Self
	 * @menu: Popupmenu
	 * @err: Error propagation and reporting
	 *
	 * Set Editor popup menu. This is the menu shown in the editor when one
	 * right-clicks on it.
	 *
	 */
	void set_popup_menu (GtkWidget *menu);
	
	/**
	 * ianjuta_editor_get_cell_iter:
	 * @obj: Self
	 * @position: Byte position where the iter will be set
	 * @err: Error propagation and reporting
	 *
	 * Creates and returns an iter for editor cells. The iter is
	 * placed at the unicode character position where the given byte
     * @position happens to fall (means given @position does not necessarily
	 * is the current position of the iter). The returned iter
	 * is cell (character) iter and not byte iter, so all iter operations
	 * on it are character (not byte) iteration, including all position
     * and index references in the iter. However, the @position paramter
     * passed to this function is byte position (because all editor
 	 * Aoperations are based on byte positions). @position could happen
     * to be in the middle of a unicode character and that is a vaild
     * situation.
     *
     * The iter must be
     * unreferrenced by the caller when done. The iter navigates
     * (next/previous) in step of unicode characters (one unicode
 	 * character == one cell).
	 * 
	 * Retruns: a newly created iter of IAnjutaEditorCell placed at the
	 * given position.
	 */
	IAnjutaIterable* get_cell_iter (gint position);

	interface IAnjutaEditorSelection
	{
		/**
		 * ianjuta_editor_selection_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets curerntly selected text in editor.
		 * 
		 * Returns: A newly allocated buffer of currently selected characters.
		 * NULL if there is no selection. The returned buffer must be freed after
		 * use.
		 */
		gchar* get ();
		
		/**
		 * ianjuta_editor_selection_set:
		 * @obj: Self
		 * @start: Begin of selection
		 * @end: End of selection
		 * @backward: Direction of search
		 * @err: Error propagation and reporting
		 *
		 * Select characters between start and end
		 */
		void set (gint start, gint end, gboolean backward);
		
		/**
		 * ianjuta_editor_selection_get_start:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets start position of selection text. If there is no selection,
		 * returns the current carat position.
		 *
		 * Return: Start of selection
		 */
		gint get_start ();
		
		/**
		 * ianjuta_editor_selection_get_end:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get end position of selection.
		 */
		gint get_end ();
		
		/**
		 * ianjuta_editor_selection_select_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Selects current block of code. The definition of block of code
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have block concept, in that case this
		 * method does not do anything.
		 */
		void select_block ();
		
		/**
		 * ianjuta_editor_selection_select_function:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select current function block. The definition of function block
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have function concept, in that case this
		 * method does not do anything.
		 */
		void select_function ();

		/**
		 * ianjuta_editor_selection_select_to_brace:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select to brace. Some highlight mode does not have braces concept,
		 * in that case, this method does not do anything.
		 */
		void select_to_brace ();
		
		/**
		 * ianjuta_editor_edit_select_all:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select whole buffer.
		 */
		void select_all ();

		/**
		 * ianjuta_editor_selection_replace:
		 * @obj: Self
		 * @text: Replacement text.
		 * @length: Length of the text to used in @text.
		 * @err: Error propagation and reporting
		 *
		 * Replaces currently selected text with the @text. Only @length amount
		 * of characters are used from @text buffer to replace.
		 */
		void replace (const gchar *text, gint length);
		
		/**
		 * ianjuta_editor_selection_cut:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Cut selection to clipboard.
		 */
		void cut ();
	
		/**
		 * ianjuta_editor_selection_copy:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Copy selection to clipboard.
		 */
		void copy ();
		
		/**
		 * ianjuta_editor_selection_paste:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Paste clipboard at current position.
		 */
		void paste ();
	
		/**
		 * ianjuta_editor_selection_clear:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Clear selection
		 */
		void clear ();
	}
	
	interface IAnjutaEditorConvert
	{
		/**
		 * ianjuta_editor_convert_to_upper:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to uppercase.
		 *
		 */
		void to_upper (gint start_position, gint end_position);
		
		/**
		 * ianjuta_editor_convert_to_lower:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to lowercase
		 *
		 */
		void to_lower (gint start_position, gint end_position);
	}
	
	interface IAnjutaEditorLineMode
	{
		enum Type
		{
			LF,
			CR,
			CRLF
		}
		
		/**
		 * ianjuta_editor_line_mode_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get current line ending mode. It is auto-detected from the
		 * buffer contents.
		 */
		Type get ();
		
		/**
		 * ianjuta_editor_line_mode_set:
		 * @obj: Self
		 * @mode: Line mode to set.
		 * @err: Error propagation and reporting
		 *
		 * Set the line ending mode to the given @mode. Existing line end
		 * characters in the buffer are not touched. Only the newly added
		 * texts will have @mode line end characters.
		 */
		void set (Type mode);

		/**
		 * ianjuta_editor_line_mode_convert:
		 * @obj: Self
		 * @mode: Line mode to convert.
		 * @err: Error propagation and reporting
		 *
		 * Set the line ending mode to the given @mode and convert all line end
		 * characters in the buffer to @mode line end characters.
		 */
		void convert (Type mode);
		
		/**
		 * ianjuta_editor_line_mode_fix:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Convert EOL characters to majority of line mode. This is helpful
		 * when the buffer contains mixed line modes and we want to fix it.
		 */
		void fix ();
	}
	
	/* Editor assistance framework */
	interface IAnjutaEditorAssist
	{
		/* IAnjutaEdiotrAssist::assist_begin:
		 * @obj: self
		 * @context: context where assistance is required.
		 * 
		 * When certain context is encountered and assistance is required
		 * to complete it, this signal is emitted by the editor. For example
		 * it could be emitted when the user typed "var->" or "var." in a c
		 * source code.
		 * 
		 * Another example is to emit it when the user has typed the begining of
		 * a word, for a simple word completion.
		 *
		 * Yet another example is to emit it when the user has typed something
		 * like "function (" for a fuction call tip assistance.
		 *
		 * The type of assistance provided would be based on the context
		 * provided. For example in case of word completion of members
		 * completeion, choices would be presented or in case of function
		 * assistance a tip would be presented with the prototype.
		 * 
		 * Each emission of assist_begin() must match with corresponding
		 * assist_end(), otherwise the assist stack could be corrupted --
		 * just like subroutine 'call' and 'return'. The only situation where
		 * it should be followed is when assist_cancel is emitted, in which
		 * case the whole assist stack is collapsed and everything is reset.
		 * 
		 */
		void ::assist_begin (const gchar *context);
		
		/* IAnjutaEdiotrAssist::assist_update:
		 * @obj: self
		 * @context: new context where assistance is required.
		 * 
		 * When there is more information in currect assistance context (e.g.
		 * user has typed some more), it can be updated by emitting this
		 * signal. Mainly used to narrow down the choices. There should be at
		 * least one pending assist context when this signal is emitted.
		 */
		void ::assist_update (const gchar *context);
		
		/* IAnjutaEdiotrAssist::assist_choosen:
		 * @obj: self
		 *
		 * User's selection from the choices. It is the index of the choice
		 * presented with ianjuta_editor_assist_suggest().
		 */
		void ::assist_choosen (gint selection);
		
		/* IAnjutaEdiotrAssist::assist_end:
		 * @obj: self
		 *
		 * Ends the current assistance context that was begun last. Note that
		 * each assist_end must match with corresponding assist_begin
		 * emission, unless the whole assistance is canceled with assist_cancel.
		 */
		void ::assist_end ();
		
		/* IAnjutaEdiotrAssist::assist_canceled:
		 * @obj: self
		 * 
		 * This signal is emitted when the user cancels the completion.
		 * The whole assistance stack is dropped and reset.
		 */
		void ::assist_canceled ();
		
		typedef gchar* (*ContextParser) (IAnjutaEditor *editor, gint position);
		
		/**
		 * ianjuta_editor_assist_add_trigger:
		 * @obj: Self
		 * @trigger: trigger character sequence
		 * @context_parser: Callback used to parse the context.
		 * @err: Error propagation and reporting
		 * 
		 * Add the given character sequence as a trigger for begining
		 * assist. context_parser is a callback to use to retrieve the
		 * context when the trigger happens.
		 * 
		 * By default there is always a trigger for aphanumeric
		 * characters with default context_parser picking up the word
		 * just before the carat.
		 */
		void add_trigger (const gchar *trigger, ContextParser context_parser);
		
		/*
		 * ianjuta_editor_assist_remove_trigger:
		 * @obj: Self
		 * @trigger: the trigger character sequence to remove.
		 * @err: Error propagation and reporting
		 * 
		 * Removes the trigger character sequence. If the trigger is not
		 * added, nothing happens.
		 */
		void remove_trigger (const gchar *trigger);
		
		/**
		 * ianjuta_editor_assist_suggest:
		 * @obj: Self
		 * @choices: list of choices.
		 * @char_alignment: Character alignment.
		 * @err: Error propagation and reporting
		 * 
		 * Suggest a list of choices to the user. @char_alignment indicates
		 * the position before which is the known context and after which are
		 * the suggestions. Usually the editor would use this to
		 * align the choices displayed such that the carat is just at this
		 * position when the choices are displayed.
		 *
		 */
		void suggest (List<const gchar*> choices, gint char_alignment);
		
		/**
		 * ianjuta_editor_assist_tip:
		 * @obj: Self
		 * @tips: list of alternative tips.
		 * @char_alignment: Character alignment.
		 * @err: Error propagation and reporting
		 *
		 * Show tips showing more information on current context. No user feedback
		 * is required when tips are shown. @char_alignment indicates
		 * the position before which is the known context and after which are
		 * the suggestions. Usually the editor would use this to
		 * align the choices displayed such that the carat is just at this
		 * position when the choices are displayed.
		 *
		 */
		void tip (List<const gchar*> tips, gint char_alignment);
		
		/**
		 * ianjuta_editor_assist_react:
		 * @obj: Self
		 * @selection: The user selection index.
		 * @context: The context to react in.
		 * @completion: corresponding completion.
		 * @err: Error propagation and reporting
		 * 
		 * When a user makes a choice, the editor is requested to react to
		 * it. Usually the editor inserts it at the current carat position
		 * and end or update current assist context.
		 */
		void react (gint selection, const gchar *context, const gchar *completion);
		
		/**
		 * ianjuta_editor_assist_react:
		 * @obj: Self
		 * @context: The context for the suggestions.
		 * @err: Error propagation and reporting
		 *
		 * Usually the editor might have some suggestions to make
		 * for a context. For example in a simple word completion context.
		 * If the editor has no suggestions to make, it returns NULL.
		 * 
		 * Returns: A list of suggestions for the given context or NULL
		 * if there is nothing to suggest.
		 * 
		 * Returns: A list of dynamically allocated strings. The whole
		 * list, including the the strings should be freed when done.
		 */
		List<const gchar*> get_suggestions (const gchar *context);
		
		/**
		 * ianjuta_editor_edit_autocomplete:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Auto complete current word. This is a left over of old api for
		 * backward compatibility. It will be removed once we move to
		 * the new api.
		 */
		void autocomplete ();
	}
	
	interface IAnjutaEditorHover
	{
		void ::hover_over (gint position);
		void ::hover_leave (gint position);
		
		void set_timeout (gint timeout);
		void display (const gchar *info);
	}
	
	interface IAnjutaEditorLanguage
	{
		void ::language_changed (const gchar *language);
		
		const List<const gchar*> get_supported_languages ();
		const gchar *get_language_name (const gchar* language);
		const gchar *get_language ();
		void set_language (const gchar* language);
	}
	
	interface IAnjutaEditorFolds
	{
		/**
		 * ianjuta_editor_view_open_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open all folds
		 *
		 */
		void open_all ();
		
		/**
		 * ianjuta_editor_view_close_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Close all folds
		 *
		 */
		void close_all ();
		
		/**
		 * ianjuta_editor_view_toggle_fold:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open/Close current fold
		 *
		 */
		void toggle_current ();
	}
	
	/**
	 * IAnjutaEditorView:
	 * An editor view is a visual representation of the editor. An editor
	 * can have multiple views. All views of an editor show the same editor
	 * content (buffer). Consequently, any change done in one view is
	 * updated in all other views.
	 */
	interface IAnjutaEditorView
	{
		/**
		 * ianjuta_editor_view_create:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Creates a new view for the editor. The newly created view gets
		 * the user focus and scrolls to the same location as last view.
		 */
		void create ();
		
		/**
		 * ianjuta_editor_view_remove_current:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Removes currently focused editor view. It does not remove the
		 * last view of the editor. That is, if currently there is only
		 * one view of the editor, this function does nothing.
		 */
		void remove_current ();
		
		/**
		 * ianjuta_editor_view_get_count:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Total number of views currently present. It will never be less
		 * than 1. Invalid return values are considered error condition.
		 */
		gint get_count ();
	}
	
	interface IAnjutaEditorComment
	{
		/**
		 * ianjuta_editor_comment_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void block();
		
		/**
		 * ianjuta_editor_comment_box:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void box();
		
		/**
		 * ianjuta_editor_comment_stream:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void stream();
	}
	
	interface IAnjutaEditorZoom
	{
		/**
		 * ianjuta_editor_zoom_in:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Zoom in
		 */
		void in ();
		
		/**
		 * ianjuta_editor_zoom_out:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Zoom out
		 */
		void out ();
	}
	
	interface IAnjutaEditorGoto
	{
		/**
		 * ianjuta_editor_goto_start_block()
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Moves cursor to the start of the current block
		 */
		void start_block();
		
		/**
		 * ianjuta_editor_goto_end_block()
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Moves cursor to the end of the current block
		 */
		void end_block();
	}
}

/**
 * IAnjutaEditorCell:
 * Represents a cell in editor. A cell corresponds to a unicode
 * character along with all associated styles (such as colors and font).
 * A cell may or may not have style. If style is supported in the
 * editor, it is assumed all cells will have styles and hence every
 * IAnjutaEditorCell interface instance will have additionally
 * IAnjutaEditorCellStyle implemented.
 */
interface IAnjutaEditorCell
{
	#include <libanjuta/interfaces/ianjuta-editor.h>
	
	/**
	 * ianjuta_editor_cell_get_character:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the unicode character in this cell. A NULL terminated
	 * string is returned that is the multibyte unicode character.
	 * NULL is returned if the cell does not have any character.
	 * 
	 * Retruns: a newly created string representing the cell's unicode
	 * character.
	 */
	gchar *get_character ();
	
	/**
	 * ianjuta_editor_cell_get_lenth:
	 * @obj: self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the length of the cell in bytes. That is, length of the
	 * unicode character.
	 * 
	 * Returns: Length of the unicode character.
	 */
	gint get_length ();
	
	/**
	 * ianjuta_editor_cell_get_char:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the byte of the unicode character in this cell at given
	 * index @char_index. @char_index can vary from 0 to length of the
	 * unicode string minus 1. Out of range index is not allowed
	 * (asserted) and return is undefined.
	 * 
	 * Since there is dynamic allocation of unicode character string
	 * involved in ianjuta_editor_cell_get_character(), this function
	 * is mainly useful for fast iteration (such as copying data).
	 * 
	 * Retruns: a byte character.
	 */
	gchar get_char (gint char_index);
	
	IAnjutaEditorAttribute get_attribute ();
	
	interface IAnjutaEditorCellStyle
	{
		gchar* get_font_description ();
		gchar* get_color();
		gchar* get_background_color();
	}
}

interface IAnjutaBookmark
{
	/**
	 * ianjuta_bookmark_toggle:
	 * @obj: Self
	 * @location: The location where bookmark is toggled.
	 * @ensure_visible: If the location must be made visible.
	 * @err: Error propagation and reporting
	 *
	 * Toggle bookmark at given @location
	 *
	 */
	void toggle (gint location, gboolean ensure_visible);
	
	/**
	 * ianjuta_bookmark_first:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto first bookmark
	 *
	 */
	void first ();
	
	/**
	 * ianjuta_bookmark_last:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto last bookmark
	 *
	 */
	void last ();
	
	/**
	 * ianjuta_bookmark_next:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto next bookmark
	 *
	 */
	void next ();
	
	/**
	 * ianjuta_bookmark_previous:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Goto previous bookmark
	 *
	 */
	void previous ();
	
	/**
	 * ianjuta_bookmark_clear_all:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Clear all bookmarks
	 *
	 */
	void clear_all ();
}

interface IAnjutaEditorFactory
{
	#include "ianjuta-editor.h"
	
	/**
	 * ianjuta_editor_factory_new_editor:
	 * @obj: Self
	 * @uri: Uri to open
	 * @filename: filename to open
	 * @err: Error propagation and reporting
	 *
	 * Get a new GtkWidget* which implements IAnjutaEditor
	 *
	 * Return value: An object implementing IAnjutaEditor
	 */
	IAnjutaEditor* new_editor (const gchar* uri, const gchar* filename);
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	/**
	* ianjuta_document_manager_get_full_filename:
	* @obj: Self
	* @file: short filename
	* @err: Error propagation and reporting.
	* 
	* Given the short filename, finds the full path of the file, if the
	* editor that has it loaded is found. If there is no editor that has
	* this file opened, returns NULL.
	* 
	* Return value: the full path of the file, if an editor is found for it.
	*/
	const gchar* get_full_filename (const gchar *file);
	
	/**
	* ianjuta_document_manager_find_editor_with_path:
	* @obj: Self
	* @file_path: the file path.
	* @err: Error propagation and reporting.
	* 
	* Finds the editor that has the file with path @file_path loaded. Only
	* the editor that matches the file path will be searched.
	* 
	* Return value: the editor that corresponds to given file path. NULL if
	* there is no editor loaded with this file path.
	*/
	IAnjutaEditor* find_editor_with_path (const gchar *file_path);
	
	/**
	* ianjuta_document_manager_goto_file_line:
	* @obj: Self
	* @file: the file to go to.
	* @lineno: the line number in the file to go to.
	* @err: Error propagation and reporting.
	* 
	* Loads the given file if not loaded yet, set its editor as current editor
	* and moves cursor to the given line in the editor.
	* 
	* Return value: the editor where the mark has been put. NULL if none.
	*/
	IAnjutaEditor* goto_file_line (const gchar *file, gint lineno);
	
	/** 
	* ianjuta_document_manager_goto_file_line_mark:
	* @obj: Self
	* @file: the file to go to.
	* @lineno: the line number in the file to go to.
	* @mark: TRUE if the line should be marked with a marker.
	* @err: Error propagation and reporting
	* 
	* Loads the given file if not loaded yet, set its editor as current editor
	* and moves cursor to the given line in the editor. Optionally also marks
	* the line with line marker if @mark is given TRUE.
	* 
	* Return value: the editor where the mark has been put. NULL if none.
	*/
	IAnjutaEditor* goto_file_line_mark (const gchar *file, gint lineno, gboolean mark);
	
	/**
	* ianjuta_document_manager_get_current_editor:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Gets the current editor.
	* 
	* Return value: the currently active editor. NULL if none is there.
	*/
	IAnjutaEditor* get_current_editor ();
	
	/** 
	* ianjuta_document_manager_set_current_editor:
	* @obj: Self
	* @editor: the editor to set as current.
	* @err: Error propagation and reporting.
	* 
	* Sets the given editor as current editor.
	*/
	void set_current_editor (IAnjutaEditor *editor);
	
	/**
	* ianjuta_document_manager_get_editors:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Gets the current list of editors.
	*
	* Return value: the list of current available editors. The returned
	* list must be freed after use (not the editor objects in the list).
	*/
	List<IAnjutaEditor*> get_editors ();

	/**
	* ianjuta_document_manager_add_buffer:
	* @obj: Self
	* @name: Name of the editor buffer.
	* @content: Initial content of the buffer.
	* @err: Error propagation and reporting.
	* 
	* Creates a new editor buffer of the given name and sets the given
	* content as its initial content.
	* 
	* Return value: the IAnjutaEditor instance that has been added.
	*/
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);
	
	/**
	* ianjuta_document_manager_remove_buffer:
	* @obj: Self
	* @editor: Editor buffer to close.
	* @save_before: If true, saves the editor before closing.
	* @err: Error propagation and reporting.
	*
	* Closes and removes the given editor buffer. If @save_before is TRUE, also
	* saves the editor before closing.
	*
	* Return value: TRUE if the editor was removed, else FALSE.
	*/
	gboolean remove_buffer (IAnjutaEditor *editor, gboolean save_before);
}

interface IAnjutaMessageView
{
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}
	
	/**
	* IAnjutaMessageView::message_clicked:
	* @obj: Self
	* @message: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void ::message_clicked (const gchar *message);
	
	/** 
	* IAnjutaMessageView::buffer_flushed:
	* @obj: Self
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::buffer_flushed (const gchar *line);
	
	/**
	* ianjuta_message_view_buffer_append:
	* @obj: Self
	* @text: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void buffer_append (const gchar *text);
	
	/**
	* ianjuta_message_view_append:
	* @obj: Self
	* @type: fixme
	* @summary: fixme
	* @details: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void append (Type type, const gchar *summary, const gchar *details);
	
	/**
	* ianjuta_message_view_clear:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void clear ();
	
	/**
	* ianjuta_message_view_select_next:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void select_next ();
	
	/**
	* ianjuta_message_view_select_previous:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void select_previous ();
	
	/**
	* ianjuta_message_view_get_current_message:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	const gchar* get_current_message ();
	
	/**
	* ianjuta_message_view_get_all_messages:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	List<const gchar*> get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);
	
	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 */
	void remove_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of 
	 * the notebook or NULL if the message-manager is empty.
	 *
	 * Return value: Current view; #IAnjutaMessageView object.
	 * NULL, if there is no views.
	 */
	IAnjutaMessageView* get_current_view ();
	
	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	
	/**
	 * ianjuta_message_manager_get_all_views:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: A GList* of all views. You must not
	 * manipulate the list.
	 */
	List<IAnjutaMessageView*> get_all_views ();
	
	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	void set_current_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_set_view_title:
	 * @obj: Self
	 * @view: A message view
	 * @title: Sets the title of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the title of view.
	 *
	 */
	void set_view_title (IAnjutaMessageView *view, const gchar *title);
}

interface IAnjutaFileManager
{

	/**
	* IAnjutaFileManager::section_changed:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::section_changed (const gchar *uri);
	
	/**
	* ianjuta_file_manager_set_root:
	* @obj: Self
	* @root_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void set_root (const gchar *root_uri);
	
	/**
	* ianjuta_file_manager_get_selected:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	gchar* get_selected ();
	
	/**
	* ianjuta_file_manager_set_selected:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme.
	*/
	void set_selected (const gchar *uri);
}

interface IAnjutaTerminal
{
	#include <sys/types.h>
		
	/**
	* ianjuta_terminal_execute_command:
	* @obj: Self
	* @directory: fixme
	* @command: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	* 
	* Returns: fixme
	*/
	pid_t execute_command (const gchar* directory, const gchar *command);
}

interface IAnjutaProjectManager
{
	enum ElementType
	{
		UNKNOWN,
		SOURCE,
		TARGET,
		GROUP
	}
	
	enum TargetType
	{
		TARGET_UNKNOWN,
		TARGET_SHAREDLIB,
		TARGET_STATICLIB,
		TARGET_EXECUTABLE
	}
	
	// Signals
	
	/**
	* IAnjutaProjectManager::element_added:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_added (const gchar *element_uri);
	
	/** 
	* IAnjutaProjectManager::element_removed:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_removed (const gchar *element_uri);
	
	/**
	* IAnjutaProjectManager::element_selected:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::element_selected (const gchar *element_uri);
	
	// Methods
	
	/**
	* ianjuta_project_manager_get_element_type:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	ElementType get_element_type (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_elements:
	* @obj: Self
	* @element_type: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	List<const gchar*> get_elements (ElementType element_type);
	
	/**
	* ianjuta_project_manager_get_target_type:
	* @obj: Self
	* @target_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	TargetType get_target_type (const gchar *target_uri);
	
	/**
	* ianjuta_project_manager_get_targets:
	* @obj: Self
	* @target_type: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	List<const gchar*> get_targets (TargetType target_type);
	
	/**
	* ianjuta_project_manager_get_parent:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gchar* get_parent (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_children:
	* @obj: Self
	* @element_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	List<const gchar*> get_children (const gchar *element_uri);
	
	/**
	* ianjuta_project_manager_get_selected:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	gchar* get_selected ();
	
	/**
	* ianjuta_project_manager_add_source:
	* @obj: Self
	* @source_uri_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	*
	* Prompt the user to add a file to the project. If the user selects multiple files only
	* the first uri is returned.
	*
	* Returns: element URIs. Must be freed when no longer required.
	*/
	gchar* add_source (const gchar *source_uri_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_add_source_multi:
	* @obj: Self
	* @source_uris_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	*
	* Prompt the user to add a file to the project. If the user selects multiple files only
	* the first uri is returned.
	*
	* Returns: element URIs. Must be freed when no longer required.
	*/
	List<const gchar*> add_source_multi (List<const gchar*> source_uri_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_add_target:
	* @obj: Self
	* @target_name_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns:
	*/
	gchar* add_target (const gchar *target_name_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_add_group:
	* @obj: Self
	* @group_name_to_add: fixme
	* @default_location_uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	gchar* add_group (const gchar *group_name_to_add, const gchar *default_location_uri);
	
	/**
	* ianjuta_project_manager_is_open:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/ 
	gboolean is_open ();
}

interface IAnjutaTodo
{

	/**
	* ianjuta_to_do_load:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void load(const gchar *uri);
}

interface IAnjutaWizard
{

	/**
	* ianjuta_wizard_activate:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void activate();
}

interface IAnjutaDebugger
{
	#include "ianjuta-message-view.h"
	#include <sys/types.h>

	/* Types */
	enum Error
	{
		OK              =  0,
		NOT_READY       = -1,
		NOT_RUNNING     = -2,
		NOT_STOPPED     = -3,
		NOT_LOADED      = -4,
		NOT_STARTED     = -5,
		NOT_CONNECTED   = -6,
		NOT_IMPLEMENTED = -7,
		CANCEL,
		UNABLE_TO_CREATE_VARIABLE,
		UNABLE_TO_ACCESS_MEMORY,
		UNABLE_TO_OPEN_FILE,
		UNKNOWN_ERROR
	}

	enum Data
	{
		INFORMATION,
		BREAKPOINT,
		FRAME,
		VARIABLE,
		REGISTER
	}

	enum OutputType
	{
		OUTPUT,
		WARNING_OUTPUT,
		ERROR_OUTPUT,
		INFO_OUTPUT
	}

	enum State
	{
		UNDEFINED = -1,
		NO = 0,
		YES = 1	
	}	

	enum Status
	{
		BUSY,
		STOPPED,
		STARTED,
		PROGRAM_LOADED,
		PROGRAM_RUNNING,
		PROGRAM_STOPPED
	}

	enum BreakpointType
	{
		BREAK_REMOVED,
		BREAK_ON_LINE,
		BREAK_ON_ADDRESS,
		BREAK_ON_FUNCTION
	}

	struct Breakpoint
	{
		BreakpointType type;
		guint id;
		gchar *file;
		guint line;
		gchar *function;
		guint address;
		State enable;
		guint ignore;
		guint times;
		gchar *condition;
		State keep;
	}

	struct Register
	{
		guint num;
		gchar *name;
		gchar *value;
	}

	struct Frame
	{
		guint level;
		gchar *args;
		gchar *file;
		guint line;
		gchar *function;
		guint address;
	}

	struct Variable
	{
		gchar *name;
		gchar *expression;
		gchar *type;
		gchar *value;
		gboolean changed;
		gint children;
	}

	struct Memory
	{
		guint address;
		guint length;
		gchar *data;
	}


	struct ALine
	{
		guint address;
		const gchar *label;
		const gchar *text;
	}

	struct Disassembly
	{
		guint size;
		ALine data[0];	
	}	

	/* Call back functions */
	typedef void (*Callback) (const gpointer data, gpointer user_data, GError* err);
	typedef void (*GListCallback) (const GList* list, gpointer user_data, GError* err);
	typedef void (*GCharCallback) (const gchar *value, gpointer user_data, GError* err);
	typedef void (*BreakpointCallback) (const Breakpoint *breakpoint, gpointer user_data, GError* err);
	typedef void (*OutputCallback) (OutputType type, const gchar *output, gpointer user_data);
	typedef void (*MemoryCallback) (const gchar* address, guint length, const gchar *data, gpointer user_data, GError *err);
	typedef void (*VariableCallback) (Variable *variable, gpointer user_data, GError *err);

	/* Signals */

	/**
	* IAnjutaDebugger::debugger_started:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::debugger_started ();

	/**
	* IAnjutaDebugger::debugger_stopped:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::debugger_stopped ();

	/**
	* IAnjutaDebugger::program_loaded:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::program_loaded ();

	/**
	* IAnjutaDebugger::program_running:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::program_running ();

	/**
	* IAnjutaDebugger::program_stopped:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::program_stopped ();

	/**
	* IAnjutaDebugger::program_exited:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::program_exited ();

	/**
	* IAnjutaDebugger::sharedlib_event:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::sharedlib_event ();

	/**
	* IAnjutaDebugger::location_changed:
	* @obj: Self
	* @file: fixme
	* @line: fixme
	* @address: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::location_changed (const gchar* file, guint line, guint address);	

	/**
	* IAnjutaDebugger::frame_changed:
	* @obj: Self
	* @frame: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::frame_changed (guint frame);	

	/**
	* IAnjutaDebugger::debugger_ready:
	* @obj: Self
	* @status: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::debugger_ready (Status status);

	
	/**
	* ianjuta_debugger_get_status:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	Status get_status ();	

	
	/**
	* ianjuta_debugger_initialize:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean initialize (OutputCallback func, gpointer user_data);
	
	/**
	* ianjuta_debugger_load:
	* @obj: Self
	* @file: fixme
	* @mime_type: fixme
	* @source_search_directories: fixme
	* @terminal: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean load (const gchar *file, const gchar *mime_type, const List<const gchar*> source_search_directories, gboolean terminal);
	
	/**
	* ianjuta_debugger_attach:
	* @obj: Self
	* @pid: fixme
	* @source_search_directories: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean attach (pid_t pid, const List<const gchar*> source_search_directories);
	
	/**
	* ianjuta_debugger_start:
	* @obj: Self
	* @args: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean start (const gchar *args);
	
	/**
	* ianjuta_debugger_unload:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean unload ();
	
	/**
	* ianjuta_debugger_quit:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Quit the debugger, can wait until the debugger is ready.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean quit ();

	/**
	* ianjuta_debugger_abort:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Quit the debugger as fast as possible.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean abort ();
	
	/**
	* ianjuta_debugger_run:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean run ();
	
	/**
	* ianjuta_debugger_step_in:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean step_in ();
	
	/**
	* ianjuta_debugger_step_over:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean step_over ();
	
	/**
	* ianjuta_debugger_step_out:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean step_out ();
	
	/**
	* ianjuta_debugger_run_to:
	* @obj: Self
	* @uri: fixme
	* @line: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean run_to (const gchar *uri, gint line);
	
	/**
	* ianjuta_debugger_exit:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean exit ();
	
	/**
	* ianjuta_debugger_interrupt:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean interrupt ();

	
	/**
	* ianjuta_debugger_set_breakpoint_at_line:
	* @obj: Self
	* @file: fixme
	* @line: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean set_breakpoint_at_line (const gchar* file, guint line, Callback callback, gpointer user_data);

	
	/**
	* ianjuta_debugger_set_breakpoint_at_address:
	* @obj: Self
	* @address: fixme
	* @callback: fixme
	* @user_date: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean set_breakpoint_at_address (guint address, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_set_breakpoint_at_function:
	* @obj: Self
	* @file: fixme
	* @function: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean set_breakpoint_at_function (const gchar* file, const gchar* function, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_clear_breakpoint:
	* @obj: Self
	* @id: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean clear_breakpoint (guint id, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_enable_breakpoint:
	* @obj: Self
	* @id: fixme
	* @enable: fixme
	* @callback: fixme
	* @user_data: fixme	
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean enable_breakpoint (guint id, gboolean enable, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_ignore_breakpoint:
	* @obj: Self
	* @id: fixme
	* @ignore: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean ignore_breakpoint (guint id, guint ignore, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_condition_breakpoint:
	* @obj: Self
	* @id: fixme
	* @condition: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean condition_breakpoint (guint id, const gchar* condition, Callback callback, gpointer user_data);

	
	/**
	* ianjuta_debugger_inspect:
	* @obj: Self
	* @name: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean inspect (const gchar* name, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_evaluate:
	* @obj: Self
	* @name: fixme
	* @value: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean evaluate (const gchar* name, const gchar* value, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_print:
	* @obj: Self
	* @variable: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean print (const gchar *variable, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_list_local:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_local (Callback callback, gpointer user_data);

	/**
	* ianjuta_debugger_list_argument:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_argument (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_signal:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_signal (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_sharedlib:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_sharedlib (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_handle_signal:
	* @obj: Self
	* @name: fixme
	* @stop: fixme
	* @print: fixme
	* @ignore: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean handle_signal (const gchar *name, gboolean stop, gboolean print, gboolean ignore);
	
	/**
	* ianjuta_debugger_info_frame:
	* @obj: Self
	* @frame: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_frame (guint frame, Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_args:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_args (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_target:
	* @obj: Self
	* @funx: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_target (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_program:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_program (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_udot:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_udot (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_threads:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_threads (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_info_variables:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean info_variables (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_list_frame:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_frame (Callback callback, gpointer user_data);
	
	/**
	* ianjuta_debugger_set_frame:
	* @obj: Self
	* @frame: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean set_frame (guint frame);

	
	/**
	* ianjuta_debugger_list_register:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_register (Callback callback, gpointer user_data);

	/**
	* ianjuta_debugger_send_command:
	* @obj: Self
	* @command: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean send_command (const gchar *command);

	/**
	* ianjuta_debugger_callback:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean callback (Callback callback, gpointer user_data);

	/**
	* ianjuta_debugger_enable_log:
	* @obj: Self
	* @log: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	void enable_log (IAnjutaMessageView *log);

	/**
	* ianjuta_debugger_disable_log:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	void disable_log ();
}

interface IAnjutaCpuDebugger
{
	#include "ianjuta-debug-manager.h"
	#include "ianjuta-debugger.h"
	#include "ianjuta-message-view.h"
	#include <sys/types.h>

	/**
	* ianjuta_debugger_list_register:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_register (IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_update_register:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean update_register (IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_write_register:
	* @obj: Self
	* @value: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean write_register (IAnjutaDebuggerRegister *value);

	/**
	* ianjuta_debugger_inspect_memory:
	* @obj: Self
	* @address: fixme
	* @length: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean inspect_memory (guint address, guint length, IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_disassemble:
	* @obj: Self
	* @address: fixme
	* @length: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* Disassemble a part of the memory
	*
	* Returns: TRUE if sucessful else FALSE and check err to get more
	*          detail.
	*/
	gboolean disassemble (guint address, guint length, IAnjutaDebuggerCallback callback, gpointer user_data);
}

interface IAnjutaVariableDebugger
{
	#include "ianjuta-debug-manager.h"
	#include "ianjuta-debugger.h"
	#include <sys/types.h>

	/**
	* ianjuta_variable_debugger_create:
	* @obj: Self
	* @name: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean create (const gchar *name, IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_variable_debugger_list_children:
	* @obj: Self
	* @name: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean list_children (const gchar *name, IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_variable_debugger_evaluate:
	* @obj: Self
	* @name: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean evaluate (const gchar *name, IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_variable_debugger_assign:
	* @obj: Self
	* @name: fixme
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean assign (const gchar *name, const gchar *value);

	/**
	* ianjuta_variable_debugger_update:
	* @obj: Self
	* @callback: fixme
	* @user_data: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean update (IAnjutaDebuggerCallback callback, gpointer user_data);

	/**
	* ianjuta_variable_debugger_delete:
	* @obj: Self
	* @name: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	*
	* Returns: fixme
	*/
	gboolean delete_var (const gchar *name);
}

interface IAnjutaDebugManager
{
	#include "ianjuta-debugger.h"

	/* Signals */

	/**
	* IAnjutaDebugManager::breakpoint_changed:
	* @obj: Self
	* @breakpoint: Breakpoint
	* @err: Error propagation and reporting.
	* 
	* fixme
	*/
	void ::breakpoint_changed (IAnjutaDebuggerBreakpoint *breakpoint);
}

interface IAnjutaVcs
{
	/**
	 * ianjuta_vcs_add:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Add filename to the cvs repositry.
	 */
	void add(const gchar* filename);
	
	/**
	 * ianjuta_cvs_remove:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Remove filename to the cvs repositry. Note that the file
	 * is not removed physicly. This function will fail if the file
	 * still exists on disc.
	 */
	void remove(const gchar* filename);
	
	/**
	 * ianjuta_vcs_update:
	 * @filename: String with the filename
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Update filename with the cvs repositry.
	 */
	void update(const gchar* filename, gboolean recurse);
	
	/**
	 * ianjuta_vcs_commit:
	 * @filename: String with the filename
	 * @log: The log message for the commit or ""
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Commit changes in filename to the cvs repositry.
	 */
	void commit(const gchar* filename, const gchar* log, gboolean recurse);	
}

interface IAnjutaMacro
{
	/**
	 * ianjuta_macro_insert:
	 * @key: Key of the macro
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Insert Macro to editor
	 */
	void insert(const gchar* key);
}

interface IAnjutaSymbol
{
	#include <gdk/gdkpixbuf.h>
	
	enum Type
	{
		TYPE_UNDEF = 0,                // Unknown type
		TYPE_CLASS = 1,                // Class declaration
		TYPE_ENUM = 2,                 // Enum declaration
		TYPE_ENUMERATOR = 4,           // Enumerator value
		TYPE_FIELD = 8,                // Field (Java only)
		TYPE_FUNCTION = 16,            // Function definition
		TYPE_INTERFACE = 32,           // Interface (Java only)
		TYPE_MEMBER = 64,              // Member variable of class/struct
		TYPE_METHOD = 128,             // Class method (Java only)
		TYPE_NAMESPACE = 256,          // Namespace declaration
		TYPE_PACKAGE = 512,            // Package (Java only)
		TYPE_PROTOTYPE = 1024,         // Function prototype
		TYPE_STRUCT = 2048,            // Struct declaration
		TYPE_TYPEDEF = 4096,           // Typedef
		TYPE_UNION = 8192,             // Union
		TYPE_VARIABLE = 16384,         // Variable
		TYPE_EXTERNVAR = 32768,        // Extern or forward declaration
		TYPE_MACRO = 65536,            //  Macro (without arguments)
		TYPE_MACRO_WITH_ARG = 131072,  // Parameterized macro
		TYPE_FILE = 262144,            // File (Pseudo tag)
		TYPE_OTHER = 524288,           // Other (non C/C++/Java tag)
		TYPE_MAX = 1048575             // Maximum value
	}

	// Field masks -- used mainly for search
	enum Field
	{
		FIELD_NONE = 0,                 // Undefined
		FIELD_NAME = 1,                 // Name field
		FIELD_TYPE = 2,                 // Type field
		FIELD_FILE = 4,                 // File field
		FIELD_LINE = 8,                 // Line number field
		FIELD_POSITION = 16,            // Byte pos of symbol (Obsolete)
		FIELD_SCOPE = 32,               // Scope of the symbol field
		FIELD_INHERITANCE = 64,         // Parent classes
		FIELD_ARGUMENTS = 128,          // Argument list
		FIELD_LOCAL = 256,              // If it has local scope
		FIELD_TIME = 512,               // Modification time (File symbol only)
		FIELD_VARTYPE = 1024,           // Variable Type
		FIELD_ACCESS = 2048,            // Access type
		FIELD_IMPLEMENTATION = 4096,    // Implementation (e.g. virtual)
		FIELD_LANGUAGE = 8192,          // Language (File symbols only)
		FIELD_INACTIVE = 16384,         // Inactive file (File symbols only)
		FIELD_POINTER = 32768,          // Inactive file (File symbols only)
		FIELD_MAX = 65535               // Maximum value
	}
	
	// Methods
	Type type ();                // Symbol type
	const gchar *name ();        // Symbol name
	const gchar *args ();        // Args list (functions/prototypes/macros)
	const gchar *scope ();       // Scope of symbol
	const gchar *inheritance (); // Parent classes
	const gchar *var_type ();    // Variable type (maps to struct for typedefs)
	gchar access ();             // Access type (public/protected/private/etc.)
	gchar impl ();               // Implementation (e.g. virtual)
	const gchar *file ();        // File in which the symbol occurs
	gulong line ();              // Line number of the symbol
	gboolean is_local ();        // Is the symbol of local scope
	guint pointer_order ();      // The number of pointer signs
	
	GdkPixbuf *icon ();          // Pixbuf icon representing the symbol
}

interface IAnjutaSymbolManager
{
	#include "ianjuta-iterable.h"
	#include "ianjuta-symbol.h"

	/**
	* ianjuta_symbol_manager_search:
	* @obj: Self
	* @match_types: fixme
	* @match_name: fixme
	* @partial_name_match: fixme
	* @global_search: fixme
	* @err: Error propagation and reporting.
	* 
	* Database query. Returned iterable must be unrefed after use.
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* search (IAnjutaSymbolType match_types, const gchar *match_name, gboolean partial_name_match, gboolean global_search);
	
	/**
	* ianjuta_symbol_manager_get_members:
	* @obj: Self
	* @symbol_name: fixme
	* @global_search: fixme
	* @err: Error propagation and reporting.
	* 
	* Database query. Returned iterable must be unrefed after use.
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* get_members (const gchar *symbol_name, gboolean global_search);
	
	/**
	* ianjuta_symbol_manager_get_parents:
	* @obj: Self
	* @symbol_name: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* get_parents (const gchar *symbol_name);
	
	/**
	* ianjuta_symbol_manager_get_completions_at_position:
	* @obj: Self
	* @symbol_name: fixme
	* @err: Error propagation and reporting.
	* 
	* fixme
	* 
	* Returns: fixme
	*/
	IAnjutaIterable* get_completions_at_position (const gchar* file_uri, const gchar *text_buffer, const gint text_length, const gint text_pos);
}

interface IAnjutaPrint
{
	/**
	* ianjuta_print_print:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Print the plugin (the file in case of the editor). In most cases this will show
	* a print dialog
	*/
	void print();
	
	/**
	* ianjuta_print_print:
	* @obj: Self
	* @err: Error propagation and reporting.
	* 
	* Show print preview dialog
	*/

	void print_preview();
}

interface IAnjutaLanguageSupport
{
    List<const gchar*> get_supported_languages ();
    gboolean supports(const gchar *language);
}

interface IAnjutaPreferences
{
	#include <libanjuta/anjuta-preferences.h>
	/**
	 * ianjuta_preferences_merge:
	 * @obj: Self
	 * @prefs: AnjutaPreferences to install to
	 * @err: Error propagation and reporting.
	 * 
	 * When called, the plugin should install it's preferences
	 */
	void merge(AnjutaPreferences* prefs);
	
	/**
	 * ianjuta_preferences_unmerge:
	 * @obj: Self
	 * @prefs: AnjutaPreferences to install to
	 * @err: Error propagation and reporting.
	 * 
	 * When called, the plugin should uninstall it's preferences
	 */
	void unmerge(AnjutaPreferences* prefs);
}
	
