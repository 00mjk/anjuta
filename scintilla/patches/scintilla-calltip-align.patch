diff -u scintilla/PlatGTK.cxx scintilla-new/PlatGTK.cxx
--- scintilla/PlatGTK.cxx	Fri Mar 26 22:06:20 2004
+++ scintilla-new/PlatGTK.cxx	Sun Mar 28 23:04:49 2004
@@ -1625,9 +1625,21 @@
 	oy += rc.top;
 	if (oy < 0)
 		oy = 0;
+
+	/* do some corrections to fit into screen */
+	int sizey = rc.bottom - rc.top;
+	int screenWidth = gdk_screen_width();
+	int screenHeight = gdk_screen_height();
+	if (sizex > screenWidth)
+		ox = 0; /* the best we can do */
+	else
+		if (ox + sizex > screenWidth)
+			ox -= ox + sizex - screenWidth;
+	if (oy + sizey > screenHeight)
+		oy -= oy + sizey - screenHeight;
+
 	gtk_widget_set_uposition(PWidget(id), ox, oy);
 #if 0
-
 	GtkAllocation alloc;
 	alloc.x = rc.left + ox;
 	alloc.y = rc.top + oy;
@@ -1635,7 +1647,7 @@
 	alloc.height = rc.bottom - rc.top;
 	gtk_widget_size_allocate(id, &alloc);
 #endif
-	gtk_widget_set_usize(PWidget(id), rc.right - rc.left, rc.bottom - rc.top);
+	gtk_widget_set_usize(PWidget(id), sizex, sizey);
 }
 
 PRectangle Window::GetClientPosition() {
diff -u scintilla/ScintillaGTK.cxx scintilla-new/ScintillaGTK.cxx
--- scintilla/ScintillaGTK.cxx	Fri Mar 26 22:06:20 2004
+++ scintilla-new/ScintillaGTK.cxx	Sun Mar 28 23:04:49 2004
@@ -1115,7 +1115,6 @@
 	gtk_drawing_area_size(GTK_DRAWING_AREA(PWidget(ct.wDraw)),
 	                      rc.Width(), rc.Height());
 	ct.wDraw.Show();
-	ct.wCallTip.Show();
 	//gtk_widget_set_usize(PWidget(ct.wCallTip), rc.Width(), rc.Height());
 	gdk_window_resize(PWidget(ct.wCallTip)->window, rc.Width(), rc.Height());
 }
diff -u scintilla/include/SString.h scintilla-new/include/SString.h
--- scintilla/include/SString.h	Fri Mar 26 22:06:20 2004
+++ scintilla-new/include/SString.h	Sun Mar 28 23:04:52 2004
@@ -175,6 +175,22 @@
 		else
 			return "";
 	}
+
+	/** Attach to a string allocated by means of StringAlloc(len). */
+	SString &attach(char *s_, lenpos_t sLen_ = measure_length, lenpos_t sSize_ = measure_length) {
+		delete []s;
+		s = s_;
+		if (!s) {
+			sLen = sSize = 0;
+		}
+		else
+		{
+			sLen = (sLen_ == measure_length ? strlen(s) : sLen_);
+			sSize = (sSize_ == measure_length ? sLen + 1 : sSize_);
+		}
+		return *this;
+	}
+
 	/** Give ownership of buffer to caller which must use delete[] to free buffer. */
 	char *detach() {
 		char *sRet = s;
@@ -358,6 +374,18 @@
 			sNew[len] = '\0';
 		}
 		return sNew;
+	}
+	/**
+	 * Allocate uninitialized memory big enough to fit a string of the given length
+	 * @return the pointer to the new string
+	 */
+	static char *StringAllocate(
+		lenpos_t len)
+	{
+		if (len >= 0 && len != measure_length)
+			return new char [len + 1];
+		else
+			return 0;
 	}
 };
