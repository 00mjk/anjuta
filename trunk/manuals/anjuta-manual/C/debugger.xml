<!-- ============= Debugging ====================== -->
 <chapter id="debugging">
  <title>Debugging</title>
  <para>
   <emphasis>To debug is human. To fix it is divine...</emphasis>
  </para>
  <para>
   Well, the <emphasis>human</emphasis> part is what this section is about. The 
   <emphasis>divine</emphasis> part is up to you!
  </para>
  <para>
   When a program does not behave in the way it is supposed to, we say the program
   contains a bug or bugs. This does not refer to compilation errors &mdash; those are 
   simply errors and they are relatively easy to clear, because the compiler tells you 
   where the problems are. On the other hand, <emphasis>bugs</emphasis> are errors 
   that happen during the execution of the program and they can be hard (sometimes very hard!) 
   to detect.
  </para>
  <para>
   Any program that you think is bug-free is never completely bug-free. All we can try 
   to do is to reduce the number of bugs contained in the program. The process of removing 
   bugs is known as <emphasis>debugging</emphasis>, and the tool that is used for debugging 
   is called the <emphasis>debugger</emphasis>. <application>Anjuta</application> provides a 
   very user-friendly and powerful debugging environment (actually, a GUI wrapper over 
   <application>gdb</application>, a powerful command line debugging tool and standard on Linux).
  </para>
  <para>
   A debugger tracks and traces the execution of the program and provides various 
   views of information needed to study the execution of the program.
  </para>

  <note>
   <para>
    The debugger has been heavily changed since anjuta 2.0.2. Some features have
    been dropped but will be reenabled, a few have been added.
   </para>
  </note>

 <!-- Debugger: Start and stop -->

 <sect1 id="debugger-session">
  <title>Start and stop</title>

  <para>
   There are two ways to start the debugger:
   <itemizedlist>
    <listitem><para><emphasis>Running an executable</emphasis></para></listitem>
    <listitem><para><emphasis>Attaching to a process</emphasis></para></listitem>
   </itemizedlist>
  </para>

  <sect2 id="debug-run">
   <title>Running an executable</title>
   <para>
    Choose the menu item
    <menuchoice><guisubmenu>Debug</guisubmenu><guimenuitem>Run Target&hellip;</guimenuitem></menuchoice>
    to display a dialog box where you can select
    the executable that you want to debug, the command line parameters
    and if you want a terminal or not. The popup menu of the target combo box
    is already filled with all executables of the current project, so you can easily
    select one of them. But it is not mandatory, you can select any other executable.
    The debugger accepts libtool executable, I mean script wrapping the real
    executable generated by libtool. When you have set everything you can click on
    <guibutton>Execute</guibutton>
    to start the debugger, load your program and stop at its beginning.
   </para>
   <tip>
    <para>
     In order to better user the debugger, it is recommended to debug program
     with debugging information (-g for gcc) and no optimization (-O0 for gcc).
    </para>
   </tip>
  </sect2>
	
  <sect2 id="debug-attach">
  <title>Attaching to a Process</title>
   <para>
    It is also possible to attach to a running process for debugging. Choose the menu item
    <menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Attach to Process &hellip;</guimenuitem></menuchoice>. A list of all the
    process running on the system will appear. 
   </para>
   <figure id="attach">
    <title>Attach to Process dialog</title>
    <screenshot>
	<screeninfo>Attach to Process dialog</screeninfo>
     <graphic fileref="figures/attach.png" format="PNG" srccredit="andyp"></graphic>
    </screenshot>
   </figure>
   <para>	
    Select the process to attach to and click <guibutton>OK</guibutton>.
   </para>
   <note>
    <para>
     It is currently not possible to load symbol information for the attached
     process. 
    </para>
   </note>
  </sect2>
  
  <sect2 id="debug-restart">
   <title>Restarting an executable</title>
   <para>
    After running a executable at least one time, you can
    choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Restart Target</guimenuitem></menuchoice> to restart your program.
    It is just a shortcut that will stop the debugger if it is currently running
    and restart it with the last executable. 
   </para>
  </sect2>

  <sect2 id="debug-stop">
   <title>Stopping the Debugger</title>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Stop Debugger</guimenuitem></menuchoice> to stop the debugger.
    This option will kill the program which is being debugged. If the debugger has
    been attached to a running process, it will just detach from it without killing
    it. You will get a confirmation box if a program is currently attached or running.
   </para>
  </sect2>

 </sect1>
 
 <!-- Debugger: Execution -->
 
 <sect1 id="debugger-exec">
  <title>Execution</title>
  <para>
   Execution of a program in the debugger can be finely controlled. The program can be 
   executed in single steps, or allowed to continue until it encounters a breakpoint. 
   Executing like this is essential for tracking program behaviour. Like a video editing 
   session, the program can be executed in <emphasis>slow motion</emphasis>
   with the ability to go forward, pause, stop, and so on.
  </para>
  <para>
   The methods that can be used to execute a program in the debugger are described in 
   the next few sections.
  </para>
  
  <sect2 id="dbg-step-in">
   <title>Single stepping (step in)</title>
   <para>
    Single stepping executes only one statement of the program (from the place where it 
	has stopped) and then returns control. If the statement that is executed contains one 
	or more functions, the debugger tries to step inside the functions (in the sequence in 
	which the functions are executed). Once the statement is executed and
    control is passed back, it is possible to study the various program parameters.
   </para>
   <para>
    If the program need to been started to use single stepping.
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Step In</guimenuitem></menuchoice>
    or click on the <guibutton>Step In</guibutton> icon in the 
	<interface>Debug toolbar</interface> to step into a program.
   </para>
  </sect2>

  <sect2 id="dbg-step-over">
   <title>Single stepping (step over)</title>
   <para>
    <emphasis>Step over</emphasis> is similar to <emphasis>step in</emphasis>,
    except that it does not step inside any function in the statement being executed.
    The statement will be executed in one go.
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Step Over</guimenuitem></menuchoice>
    or click on the <guibutton>Step Over</guibutton> icon in the 
	<interface>Debug toolbar</interface> to step over statements in a program.
   </para>
   <note>
    <para>
     If a dynamic library is loaded during the step, the program will not
     stop at the end of the step. But it will run until it finds a breakpoint or you
     stop it.
    </para>
   </note>
  </sect2>
  
  <sect2 id="dbg-step-out">
   <title>Single stepping (step out)</title>
   <para>
    <emphasis>Step out</emphasis> will execute the current function until it 
	returns. The program will be stopped once it exits from the function. 
	Step out is not really single stepping, because it does not only execute 
	a single statement &mdash; it executes the whole function until that 
	function returns to the calling function.
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Step Out</guimenuitem></menuchoice>
    or click on the <guibutton>Step Out</guibutton> icon in the 
	<interface>Debug toolbar</interface> to step out in a program.
   </para>
  </sect2>
  
  <sect2 id="dbg-run">
   <title>Run/Continue</title>
   <para>
    This option will continue the execution of the program until a breakpoint is 
	encountered, or the program exits.
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Run/Continue</guimenuitem></menuchoice>
    or click on the <guibutton>Run/Continue</guibutton> icon in the 
	<interface>Debug toolbar</interface> to continue the execution of a program.
    </para>
  </sect2>

  <sect2 id="dbg-runto">
   <title>Run To</title>
   <para>
    This option will continue the execution of the program until the line where
    cursor is is reached. 
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Run to Cursor</guimenuitem></menuchoice>
    or click on the <guibutton>Run to Cursor</guibutton> icon in the 
	<interface>Debug toolbar</interface> to run until the line at cursor is reached.
    </para>
  </sect2>
  
  <sect2 id="dbg-stop">
   <title>Stop Program</title>
   <para>
    While the program is running and has control, no debugging tasks can be 
	performed. To obtain control while the program is running, choose the menu item
	<menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Interrupt Program</guimenuitem></menuchoice> or click on the
    <guibutton>Stop Program</guibutton> icon in the <interface>Debug toolbar</interface>.
    This will interrupt the program and return control to the debugger.
   </para>
  </sect2>
  
 </sect1>
 
<!-- ============= Debugging: Breakpoints ====================== -->
 
 <sect1 id="debugging-breaks">
  <title>Breakpoints</title>
  <para>
   When debugging a program, it is useful to be able to stop the execution of the program at
   a particular point, so that the state of the program can be examined at that location. 
   Breakpoints enable this to happen. Breakpoints can be set at different locations in a 
   source file, and then the program is allowed to run. When a breakpoint is encountered, 
   the execution of the program is suspended, enabling expressions to be evaluated, 
   variables to be inspected, the stack trace to be studied, and so on.
  </para>

  <sect2 id="breaks-list">
   <title>Listing Breakpoints</title>
   <para>
    The <interface>Breakpoint list window</interface> can be opened by 
	choosing <menuchoice><guisubmenu>View</guisubmenu>
    <guimenuitem>Breakpoints</guimenuitem></menuchoice>
   </para>
   <para>
    <figure>
      <title>Breakpoint view</title>
      <screenshot>
       <screeninfo>Breakpoint view</screeninfo>
       <graphic fileref="figures/brk_dlg.png" format="PNG" srccredit="andyp"></graphic>
      </screenshot>
    </figure>
   </para>
   <para>
    <emphasis>Location</emphasis>, refers to the location of the code in the source
    file. <emphasis>Location</emphasis> can be specified in any of the following 
    formats:
   </para>
   <para>
    <orderedlist>
     <listitem><para>File_name:Line_number</para></listitem>
     <listitem><para>Function_name</para></listitem>
     <listitem><para>File:Function_name</para></listitem>
    </orderedlist>
   </para>
   <para>
    The first one is obvious &mdash; The location refers to the line number 
    <emphasis>Line_number</emphasis> in the source file <emphasis>File</emphasis>. 
    The second refers to the first line of the function 
    <emphasis>Function_name</emphasis>. The third is similar to the second, except that 
    this notation is used where there is more than one function with the name 
    <emphasis>Function_name</emphasis> in the program. It is possible to 
    differentiate between them by providing the <emphasis>File</emphasis>, so the 
    notation refers to the function <emphasis>Function_name</emphasis> in the 
    file <emphasis>File</emphasis>.
   </para>
   <para>
    Two parameters can be associated with each breakpoint:
    <orderedlist>
     <listitem><para>Break condition</para></listitem>
     <listitem><para>Pass count</para></listitem>
    </orderedlist>
   </para>
   <para>
    The <emphasis>Break condition</emphasis> is a valid C 
    expression which should evaluate to a Boolean value &mdash; that is, the 
    evaluation of the expression should result in either TRUE(1) or FALSE(0). 
    If the final evaluation value is not a Boolean value, then it will be 
    appropriately type casted to a Boolean.
   </para>
   <para>
    Every time the breakpoint is encountered during the execution, the break 
    condition will be evaluated. The debugger will break the execution only if 
    the evaluation results in a TRUE value, otherwise it will continue the 
    execution as though there had been no breakpoint.
   </para>
   <para>
    The default value of <emphasis>Break condition</emphasis> is always TRUE. 
    The debugger will break the execution at the breakpoint location.
   </para>
   <para>
    The <emphasis>Pass count</emphasis> is an integer (unsigned) value which 
    tells the debugger to skip the breakpoint that number of times before it 
    is considered. <emphasis>Pass count</emphasis> has a higher priority than 
    the <emphasis>Break condition</emphasis>. Only when the 
    <emphasis>Pass count</emphasis> reaches zero will the debugger evaluate the 
    <emphasis>Break condition</emphasis> (if any condition is present). If there 
    is no condition, the debugger will break the execution once the 
    <emphasis>Pass count</emphasis> counts down to zero.
   </para>
   <para>
    The default value of the <emphasis>Pass count</emphasis> is zero. The 
    breakpoint will be considered when it is first encountered.
   </para>
   <note>
    <para>
     All breakpoints are kept across anjuta session even if they correspond to
     a non existing place. The interface try to set them each time the program
     is started or a new dynamic library is loaded.
    </para>
   </note>
  </sect2>  

  <sect2 id="breaks-set">
   <title>Adding or Setting Breakpoints</title>
   <para>
    Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Add Breakpoint&hellip;</guimenuitem></menuchoice>
    or <menuchoice><guimenuitem>Add Breakpoint&hellip;</guimenuitem></menuchoice>
	in the breakpoint list popup menu to open the add breakpoint dialog.
   </para>
   <para>
    <figure>
      <title>Breakpoint add dialog</title>
      <screenshot>
	   <screeninfo>Breakpoint add dialog</screeninfo>
       <graphic fileref="figures/brk_add.png" format="PNG" srccredit="mkv"></graphic>
      </screenshot>
    </figure>
   </para>
   <para>
    Enter the location at which to set the breakpoint. Optionally, enter
    the <emphasis>Break condition</emphasis> and the <emphasis>Pass count</emphasis>
    in the appropriate entry boxes. Click <guibutton>OK</guibutton> to set the 
	breakpoint.
   </para>
   <para>
    A breakpoint may also be by selecting a line in the editor
    and choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Toggle Breakpoint</guimenuitem></menuchoice>, the editor popup
	menu item
	<menuchoice><guimenuitem>Toggle Breakpoint</guimenuitem></menuchoice>
    or the <guibutton>Toggle Breakpoint</guibutton> icon in the 
	<interface>Debug toolbar</interface>.
   </para>
   <tip>
    <para>
     Breakpoints can be added even if the debugger is not started or in dynamic
     library not loaded yet. But they cannot be added while a program is running
     under control of the debugger.
    </para>
   </tip>
  </sect2>
  
  <sect2 id="breaks-edit">
   <title>Editing Breakpoints</title>
   <para>
    It is possible to change the condition of a breakpoint of the pass count by
    selecting the breakpoint to edit in the breakpoint list and click in the
    popup menu item <menuchoice><guimenuitem>Edit Breakpoint</guimenuitem></menuchoice>.
   </para>
   <para>
    Edit the entries as required and click on <guibutton>OK</guibutton> to
    commit the changes.
   </para>
  </sect2>

  <sect2 id="breaks-del">
   <title>Deleting Breakpoints</title>
   <para>
    Select the breakpoint to delete in the breakpoint list view	and click on
    <menuchoice><guimenuitem>Remove Breakpoint</guimenuitem></menuchoice>.
   </para>
   <para>
    A existing breakpoint may also be deleted by selecting the line in the editor
    and choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Toggle Breakpoint</guimenuitem></menuchoice>,
    the editor popup menu item
	<menuchoice><guimenuitem>Toggle Breakpoint</guimenuitem></menuchoice>
    or the <guibutton>Toggle Breakpoint</guibutton> icon in the 
	<interface>Debug toolbar</interface>.
   </para>
  </sect2>

  <sect2 id="breaks-enbdis">
   <title>Enabling or Disabling Breakpoints</title>
   <para>
    Click on the Enable column of the <interface>Breakpoint list window</interface> or
    in the menu item <menuchoice><guimenuitem>Enable Breakpoint</guimenuitem></menuchoice>
    to enable or disable the selected breakpoint. 
	The breakpoint will be enabled or disabled, depending on the current state.
   </para>
   <para>
    To disable all breakpoints, click on <menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Disable All Breakpoints</guimenuitem></menuchoice> or on
    <menuchoice><guimenuitem>Disable All Breakpoints</guimenuitem></menuchoice> in
    the breakpoint list popup menu.
   </para>
  </sect2>
 </sect1>

<!-- ============= Debugging: Expressions ====================== -->
 <sect1 id="debugging-expr">
  <title>Expressions</title>

  <sect2 id="var-local">
   <title>Listing local variable</title>
   <para>
    When a program is running under the control of the debugger, the 
    <interface>Locals list window</interface> can be opened by 
    choosing <menuchoice><guisubmenu>View</guisubmenu>
    <guimenuitem>Locals</guimenuitem></menuchoice>
   </para>
   <para>
    Local variables of the current frame (the current funtion in which the program control
    is present) are displayed in the <interface>Locals list window</interface>.
    During execution of the program (eg. during single stepping), local
    variables will be updated. If any varialble value was changed in the last debugging step, its
    value will be highlight in red. The variables are presented in a tree form for easy
    view.
    <figure>
      <title>Local variables</title>
      <screenshot>
	  <screeninfo>Local variables</screeninfo>
       <graphic fileref="figures/local_variables.png" format="PNG" srccredit="naba"></graphic>
      </screenshot>
    </figure>
   </para>
   <para>
    The value of a local variable can be modified by selecting it and clicking in
    the value column.
   </para>
   <note>
    <para>
     Gdb is more and more often used as a back end for a graphical front end. It
     has been improved recently in this area. It is recommanded to use the latest
     version (6.6) of gdb. On older version, gdb can crash when the front end
     ask for an pointer with an invalid (but not used) value.
    </para>
   </note>
  </sect2>

  <sect2 id="var-watch">
   <title>Listing watched expressions</title>
   <para>
    Inspecting or evaluating an expression provides the result only once. To continuously 
	monitor some variables or expressions, use <emphasis>expression watch</emphasis>.
   </para>
   <para>
     Choose the menu item <menuchoice><guisubmenu>View</guisubmenu><guimenuitem>Watch
	 Window</guimenuitem></menuchoice> to display the <interface>expression watch window</interface>.
   </para>
  </sect2>

  <sect2 id="watch-add">
   <title>Adding an expression to watch</title>
   <para>
    Right-click on the <interface>expression watch window</interface>
    to open the <interface>Operation menu</interface>. Choose the 
	menu item <guimenuitem>Add Watch&hellip;</guimenuitem>. Alternatively, you can
    use <menuchoice><guisubmenu>Debug</guisubmenu>
	<guimenuitem>Add Watch&hellip;</guimenuitem></menuchoice>
    A dialog prompting for the expression will appear. Enter the expression and 
    click <guibutton>OK</guibutton>.
   </para>
   <para>
    By default watch expression are updated automatically 
    each time the program is stopped. This can be changed in the add watch dialog
    or later using the <guimenuitem>Automatic update</guimenuitem> menu item in the
    <interface>expression watch window</interface> popup menu. A watched expression
    can be update manually by choosing
    <guimenuitem>Update Watch</guimenuitem> or <guimenuitem>Update All</guimenuitem> in
    the previous menu.
   </para>
   <para>
    It is not necessary to have the debugger running to add a new watch expression.
    If the debugger is not running or the corresponding expression cannot be found, 
    the front end will try to create the watch expression, each time the program
    is stopped.
   </para>
  </sect2>

  <sect2 id="watch-remove">
   <title>Removing an expression from watch</title>
   <para>
    Select the watch expression that you want to remove in the <interface>expression watch 
	window</interface>, then open the <interface>Operation menu</interface>, clicking
    with the right mouse button, and choose the 
	menu item <guimenuitem>Remove</guimenuitem> to remove it.
   </para>
   <para>
    All watch can be removed by choosing <guimenuitem>Remove All</guimenuitem> in the
    popup menu of the <interface>expression watch window</interface>.
   </para>
  </sect2>

  <sect2 id="expr-eval">
   <title>Evaluating expressions</title>
   <para>
    When control is returned from a program &mdash; possibly at a breakpoint &mdash; 
	it is possible to evaluate expressions or inspect the values of variables in the 
	program. Choose the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
    <guimenuitem>Inspect/Evaluate &hellip;</guimenuitem></menuchoice>, 
    <menuchoice><guimenuitem>Inspect/Evaluate &hellip;</guimenuitem></menuchoice>
    in the popup menu of the editor or click 
	the <guibutton>Inspect</guibutton> button on the <interface>Debug Toolbar</interface>. 
   </para>
   <para>
    A window will appear showing the result of the evaluation.
   </para>
   <para>
    If an expression is highlighted in the editor, it is already displayed else
    the window is empty. In both cases, you an select a new expression by clicking
    on the name column and writing the new expression.
   </para>
   <para>
    The expression can be added directly in the list of watched expressions by 
    clicking on <guibutton>Add</guibutton> button. 
   </para>
  </sect2>

 </sect1>

<!-- ============= Debugging: Program Stack ====================== -->
 <sect1 id="debugging-stack">
  <title>Stack Trace and Thread</title>

  <sect2 id="stack-win">
   <title>Stack Window</title>
   <para>
    The <interface>Stack trace window</interface> shows the contents of the 
	program stack. It lists all of the functions and their arguments in the 
	sequence they were called. There is also a number representing each call. 
	This number is called the <emphasis>Frame</emphasis>. Each call in the trace 
	exists in a different frame. This starts from frame 0 (the last function
    called) and grows higher as the function nesting become deeper.
   </para>
   <para>
    Choose the menu item <menuchoice><guisubmenu>View</guisubmenu><guimenuitem>Program 
	Stack</guimenuitem></menuchoice>, to open the stack trace for the program 
	being debugged.
   </para>
   <para>
    <figure>
      <title>Stack trace window</title>
      <screenshot>
	   <screeninfo>Stack trace window</screeninfo>
       <graphic fileref="figures/stack.png" format="PNG" srccredit="andyp"></graphic>
      </screenshot>
    </figure>
   </para>
   <para>
    A small arrow points to the currently selected frame in the stack trace. By 
	default, this will be frame 0, the last function called. All of the evaluation 
	and inspection of expressions or variables will be with reference to this selected 
	frame. The scope of the variables or expressions being evaluated will be limited 
	to the selected frame only. The same applies for new expressions only in the watch.
   </para>
  </sect2>
  
  <sect2 id="stack-frame">
   <title>Setting the current frame</title>
   <para>
    Double-clicking on any frame in the stack trace will set that frame as the 
	currently selected frame (the arrow will point to the frame, indicating that it 
	has been selected as the current frame). Alternatively, open the 
	<interface>Operation menu</interface> by right-clicking on the 
	<interface>Stack trace window</interface>, and choose the menu item 
	<guimenuitem>Set frame</guimenuitem> to set the frame.
   </para>
   <para>
    Changing the stack frame will change the <interface>Locals list window</interface>
    content, but not the <interface>expression watch window</interface> as each
    expression is evaluated in the frame used when it was defined.
   </para>
  </sect2>

  <sect2 id="thread-win">
   <title>Thread Window</title>
   <para>
    The <interface>Thread window</interface> show all threads used by the program
    and display the current thread. Choose the menu item <menuchoice><guisubmenu>View</guisubmenu>
    <guimenuitem>Thread</guimenuitem></menuchoice>, to open this window.
   </para>
   <para>
    A small arrow points to the current thread. When the
    programm is stopped, it correspond to the thread which has been interrupted.
    Each thread has its own stack frame,so changing the current thread will change
    the current stack frame. 
   </para>
  </sect2>

  <sect2 id="set-thread">
   <title>Setting the current thread</title>
   <para>
    Double-clicking on any thread in the thread list will set that thread as the 
	currently selected thread (the arrow will point to the thread, indicating that it 
	has been selected as the current thread). Alternatively, open the 
	<interface>Operation menu</interface> by right-clicking on the 
	<interface>Thread list window</interface>, and choose the menu item 
	<guimenuitem>Set thread</guimenuitem> to set the thread.
   </para>
   <para>
    Changing the thread will change the value of CPU registers and the current
    stack frame, so the <interface>Locals list window</interface> will change too.
   </para>
  </sect2>
 </sect1>

<!-- ============= Debugging: CPU ====================== -->
 <sect1 id="debugging-cpu">
  <title>CPU</title>

  <sect2 id="cpu-regs">
   <title>Register window</title>
   <para>
    It is possible to examine the contents of the internal registers of the 
	CPU (microprocessor). Choose the menu item <menuchoice><guisubmenu>View</guisubmenu>
	<guimenuitem>Registers</guimenuitem></menuchoice>. A window listing all 
	of the available registers in the microprocessor and their corresponding contents 
	will appear.
   </para>
   <para>
    If any register value was changed in the last debugging step, its
    value will be highlight in red. It is possible to change one register value
    by selecting it and clicking in the value column.    
   </para>
  </sect2>

  <sect2 id="cpu-memory">
   <title>Memory window</title>
   <para>
    Choose the menu item <menuchoice><guisubmenu>View</guisubmenu><guimenuitem>Memory 
	</guimenuitem></menuchoice>, to open the <interface>memory window</interface>
    for the program being debugged. This window shows the contents of all memory. 
   </para>
   <para>
    The first is the memory address in hexadecimal, the second is the memory content
    in hexadecimal too and the last column is the memory content in ascii.
   </para>
   <para>
    The addressing space of even a 32 bits microprocessor is quite big(4 Giga bytes),
    so it is very difficult to go to a particular address with the scrollbar. But
    you can click on the right mouse button, get a new menu and select
    <menuchoice><guimenuitem>Goto address</guimenuitem></menuchoice> to get
    a small edit box where you can enter an address in hexadecimal.
   </para>
  </sect2>

  <sect2 id="cpu-disassembly">
   <title>Disassembly window</title>
   <para>
    Choose the menu item <menuchoice><guisubmenu>View</guisubmenu><guimenuitem>Disassembly 
	</guimenuitem></menuchoice>, to open the <interface>disassembly window</interface>
    for the program being debugged.
	registers.
   </para>
   <para>
    The first column is the address in hexadecimal. In the second column, you can
    have a label starting at the beginning of the line and ended with a colon or
    a assembler instruction starting after 4 space characters.
   </para>
   <para>
    Again, as the addressing space is very big, the scrollbar is quite useless.
    You can click on the right mouse button, get a new menu and select
    <menuchoice><guimenuitem>Goto address</guimenuitem></menuchoice> to get
    a small edit box where you can enter an address in hexadecimal. The position
    in the disassembly window will be changed to the program counter value when
    the program is stopped.
   </para>
  </sect2>
 </sect1>

<!-- Debugger: Others-->
 <sect1 id="debugger-others">
  <title>Others</title>

  <para>
   There are a number of other debugger features used less frequently and not
   very well integrated in the new front end but which are still working.
  </para>

  <sect2 id="dbg-dyna-libs">
   <title>Dynamically loaded Libraries</title>
   <para>
    To obtain a list of the dynamic libraries used by the program, choose the 
	menu item <menuchoice><guisubmenu>Debug</guisubmenu><guisubmenu>Info</guisubmenu>
	<guimenuitem>Shared Libraries</guimenuitem></menuchoice>. This will bring 
	open a window which will list all the shared libraries the program has loaded 
	and their locations in the memory. It also shows whether the symbol table is 
	loaded or not (Yes/No).
   </para>
   <para>
    <figure>
      <title>Shared Libraries window</title>
      <screenshot>
	   <screeninfo>Shared Libraries window</screeninfo>
       <graphic fileref="figures/sharedlibs.png" format="PNG" srccredit="andyp"></graphic>
      </screenshot>
    </figure>
   </para>
  </sect2>

  <sect2 id="dbg-signal">
   <title>Kernel Signals</title>
   <para>
    Kernel signals are a way of signaling between processes in Linux. The list 
	of signals available for a program can be displayed by choosing the menu item
    <menuchoice><guisubmenu>Debug</guisubmenu><guisubmenu>Info</guisubmenu><guimenuitem>Kernel Signals</guimenuitem></menuchoice>.
    A window will open which lists all of the signals available in the system along with
    a brief description of each signal.
   </para>
   <para>
    <figure>
      <title>Kernel Signals window</title>
      <screenshot>
	   <screeninfo>Kernel Signals window</screeninfo>
       <graphic fileref="figures/signals.png" format="PNG" srccredit="andyp"></graphic>
      </screenshot>
    </figure>
   </para>
   <para>
    There are three columns which specify what to do when the signal is received:
   </para>
   
   <orderedlist>
    <listitem>
     <para><emphasis>Stop</emphasis> &mdash; this tells the debugger whether to 
	 stop the program execution (and return control) when the program receives 
	 this signal.
     </para>
    </listitem>
    <listitem>
     <para><emphasis>Print</emphasis> &mdash; this tells the debugger whether to 
	 display the received signal.
     </para>
    </listitem>
    <listitem>
     <para><emphasis>Pass</emphasis> &mdash; this tells the debugger whether to pass 
	 the signal to the program.
     </para>
    </listitem>
   </orderedlist>
   <note>
    <para>
     The popup menu that is displayed when you click on the right mouse button has
     all its item disabled because the corresponding functions are not implemented
     yet.
    </para>
   </note>
  </sect2>

  <sect2 id="dbg-files">
   <title>Information about used files</title>
   <para>
    It is possible to get some information about the files used by the debugged program.
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Target files</guimenuitem></menuchoice>. 
	A window will open displaying all informations.
   </para>
  </sect2>

  <sect2 id="dbg-program">
   <title>Information about debugged program</title>
   <para>
    It is possible to get some information about the debugged program
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Program</guimenuitem></menuchoice>. 
	A window will open displaying all informations.
   </para>
  </sect2>
 
  <sect2 id="dbg-kernel">
   <title>Information about kernel structure</title>
   <para>
    It is possible to get some information kernel data on the current process
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Kernel user struct</guimenuitem></menuchoice>. 
	A window will open displaying all informations.
   </para>
  </sect2>

  <sect2 id="var-global">
   <title>Information about global variables</title>
   <para>
    It is possible to list all global variables
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Info Global Variable</guimenuitem></menuchoice>. 
	A window will open listing all global variables.
   </para>
  </sect2>

  <sect2 id="stack-frame-info">
   <title>Information about the current frame</title>
   <para>
    It is possible to obtain information about the currently selected frame 
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Info Current Frame</guimenuitem></menuchoice>. 
	A window will open describing the current frame.
   </para>
  </sect2>

  <sect2 id="stack-arg-info">
   <title>Information about the current function arguments</title>
   <para>
    It is possible to obtain information about the arguments of the current function 
	by choosing the menu item <menuchoice><guisubmenu>Debug</guisubmenu>
	<guisubmenu>Information</guisubmenu><guimenuitem>Arguments</guimenuitem></menuchoice>. 
	A window will open describing the arguments.
   </para>
  </sect2>
  
  <sect2 id="dbg-command">
   <title>User command</title>
   <para>
    To send directly a command to the back end choose the
	menu item <menuchoice><guimenu>Debug</guimenu>
	<guimenuitem>Debugger command</guimenuitem></menuchoice>. This will bring
    a small dialog where you can enter commands that will be send to the debugger
    when you press <keycap>Return</keycap>.
   </para>
   <note>
    <para>
     The front end sends this command directly to the back end without doing any check.
     By example if you set a breakpoint like this, it will not appear in the
     <interface>breakpoint list window</interface>. It is better to avoid using this
     command unless you know exactly what you are doing.
    </para>
   </note>
  </sect2>
 </sect1> 

 </chapter>
